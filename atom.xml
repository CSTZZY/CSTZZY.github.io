<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CSTZZY</title>
  
  <subtitle>个人主页</subtitle>
  <link href="http://cstzzy.top/atom.xml" rel="self"/>
  
  <link href="http://cstzzy.top/"/>
  <updated>2023-12-10T09:28:45.308Z</updated>
  <id>http://cstzzy.top/</id>
  
  <author>
    <name>ZZY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode热题4</title>
    <link href="http://cstzzy.top/2023/12/10/24%EF%BC%9ALeetCode%E7%83%AD%E9%A2%984/"/>
    <id>http://cstzzy.top/2023/12/10/24%EF%BC%9ALeetCode%E7%83%AD%E9%A2%984/</id>
    <published>2023-12-10T02:50:00.000Z</published>
    <updated>2023-12-10T09:28:45.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked">接雨水</a></h1><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>思路及算法：</p><p>对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。</p><p>如果针对每一个元素都分别向左&#x2F;右扫描数组寻找左侧和右侧的最大值，则时间复杂度为$O(N^2)$。<br>在已获得各个元素左右两侧最大高度的前提下，计算接雨水的总量的时间复杂度将变为$O(N)$，而使用动态规划的方法可以在时间复杂度为$O(N)$的前提下找到各个元素左右两侧的最大值，思路如下：</p><ul><li>创建两个长度为n的数组：leftmax和rightmax用来存储各个元素左右两侧的最大值；</li><li>leftMax[0]&#x3D;height[0]，对于剩余的元素leftMax[i]&#x3D;max(leftMax[i−1],height[i])；</li><li>rightMax[n−1]&#x3D;height[n−1]，对于剩余的元素rightMax[i]&#x3D;max(rightMax[i+1],height[i])；</li><li>在得到leftmax和rightmax后，下标i所对应的接雨水量&#x3D;min(leftMax[i],rightMax[i])−height[i]。</li></ul><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n=height.size();</span><br><span class="line">        vector&lt;int&gt; leftmax(n);</span><br><span class="line">        leftmax[0]=height[0];</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            leftmax[i]=max(height[i],leftmax[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; rightmax(n);</span><br><span class="line">        rightmax[n-1]=height[n-1];</span><br><span class="line">        for(int i=n-2;i&gt;=0;i--)&#123;</span><br><span class="line">            rightmax[i]=max(height[i],rightmax[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            res=res+max(0,min(leftmax[i],rightmax[i])-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>其实上面的代码中的res&#x3D;res+max(0,min(leftmax[i],rightmax[i])-height[i]);没有必要写max(0,…)，因为min(leftmax[i],rightmax[i])的最小值为height[i]，即：min(leftmax[i],rightmax[i])-height[i]肯定为非负数。</p><h2 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h2><p>思路及算法：</p><p>维护一个存储height数组下标的单调栈stack，其中从栈底到栈顶的下标对应的数组 height 中的元素递减。<br>从头遍历height数组，若height[i]&lt;&#x3D;stack[stack.top()]或stack为空，则将i入栈；<br>否则，int top&#x3D;stk.top(); stk.pop(); 若此时stack为空，则将i入栈，<br>否则，此时得到一个可以接雨水的区域，left&#x3D;stk.top(); cur_width&#x3D;i-left-1; cur_height&#x3D;min(height[left],height[i])-height[top]; res+&#x3D;(cur_width*cur_height);<br>重复上述过程，直到stack为空，或height[i]&lt;&#x3D;height[stk.top()]。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n=height.size();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            while(!stk.empty()&amp;&amp;height[i]&gt;height[stk.top()])&#123;</span><br><span class="line">                int top=stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(stk.empty())</span><br><span class="line">                    break;</span><br><span class="line">                int left=stk.top();</span><br><span class="line">                int cur_width=i-left-1;</span><br><span class="line">                int cur_height=min(height[left],height[i])-height[top];</span><br><span class="line">                res+=(cur_width*cur_height);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><h2 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a>方法三：双指针</h2><p>上述两种方法的空间复杂度都为$O(N)$，下面要介绍的双指针方法的空间复杂度为$O(1)$。</p><p>下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6575828bc458853aefcd01ef.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6575828bc458853aefcd01ef.jpg"></p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n=height.size();</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=n-1;</span><br><span class="line">        int lmax=height[0];</span><br><span class="line">        int rmax=height[n-1];</span><br><span class="line">        int res=0;</span><br><span class="line">        while(l!=r)&#123;</span><br><span class="line">            if(height[l]&gt;=lmax)&#123;</span><br><span class="line">                lmax=height[l];</span><br><span class="line">            &#125;</span><br><span class="line">            if(height[r]&gt;=rmax)&#123;</span><br><span class="line">                rmax=height[r];</span><br><span class="line">            &#125;</span><br><span class="line">            if(height[l]&lt;height[r])&#123;</span><br><span class="line">                res+=(lmax-height[l++]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res+=(rmax-height[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接雨水&quot;&gt;&lt;a href=&quot;#接雨水&quot; class=&quot;headerlink&quot; title=&quot;接雨水&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/trapping-rain-water/description/?envTyp</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>Git使用SourceTree</title>
    <link href="http://cstzzy.top/2023/12/08/23%EF%BC%9Agit-%E4%BD%BF%E7%94%A8SourceTree/"/>
    <id>http://cstzzy.top/2023/12/08/23%EF%BC%9Agit-%E4%BD%BF%E7%94%A8SourceTree/</id>
    <published>2023-12-08T11:24:00.000Z</published>
    <updated>2023-12-08T11:25:05.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git使用SourceTree"><a href="#Git使用SourceTree" class="headerlink" title="Git使用SourceTree"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/1317161920364578">Git使用SourceTree</a></h1><p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。</p><p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git使用SourceTree&quot;&gt;&lt;a href=&quot;#Git使用SourceTree&quot; class=&quot;headerlink&quot; title=&quot;Git使用SourceTree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git自定义git</title>
    <link href="http://cstzzy.top/2023/12/08/22%EF%BC%9Agit-%E8%87%AA%E5%AE%9A%E4%B9%89git/"/>
    <id>http://cstzzy.top/2023/12/08/22%EF%BC%9Agit-%E8%87%AA%E5%AE%9A%E4%B9%89git/</id>
    <published>2023-12-08T10:45:00.000Z</published>
    <updated>2023-12-08T11:20:59.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git自定义git"><a href="#Git自定义git" class="headerlink" title="Git自定义git"></a>Git自定义git</h1><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208">更详细的说明</a></p><p>忽略某些文件时，需要编写.gitignore；</p><p>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：<br>如果你确实想添加该文件，可以用-f强制添加到Git：</p><pre class="highlight"><span class="line">git add -f App.class</span><br></pre><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p><pre class="highlight"><span class="line">git check-ignore -v App.class</span><br></pre><pre class="highlight"><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">配置别名</a></h2><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器</a></h2><p>暂时没有必要搭建一个单独的git服务器，因此只是简单了解了其搭建过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git自定义git&quot;&gt;&lt;a href=&quot;#Git自定义git&quot; class=&quot;headerlink&quot; title=&quot;Git自定义git&quot;&gt;&lt;/a&gt;Git自定义git&lt;/h1&gt;&lt;h2 id=&quot;忽略特殊文件&quot;&gt;&lt;a href=&quot;#忽略特殊文件&quot; class=&quot;head</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitGitub和Gitee的使用</title>
    <link href="http://cstzzy.top/2023/12/08/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://cstzzy.top/2023/12/08/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-08T08:59:00.000Z</published>
    <updated>2023-12-08T09:35:44.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitGithub和Gitee的使用的使用"><a href="#GitGithub和Gitee的使用的使用" class="headerlink" title="GitGithub和Gitee的使用的使用"></a>GitGithub和Gitee的使用的使用</h1><p>廖老师的教程中关于github的使用的介绍比较少，可以参考<a href="https://blog.csdn.net/dangfulin/article/details/107868575?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-107868575-blog-128958918.235%5Ev39%5Epc_relevant_3m_sort_dl_base2&spm=1001.2101.3001.4242.1&utm_relevant_index=3">此链接</a>中更详细的教程。</p><p>Gitee的使用与Github的使用基本相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GitGithub和Gitee的使用的使用&quot;&gt;&lt;a href=&quot;#GitGithub和Gitee的使用的使用&quot; class=&quot;headerlink&quot; title=&quot;GitGithub和Gitee的使用的使用&quot;&gt;&lt;/a&gt;GitGithub和Gitee的使用的使用&lt;/</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitGitub和Gitee的使用</title>
    <link href="http://cstzzy.top/2023/12/08/vx_recycle_bin/20231208/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1.md/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1/"/>
    <id>http://cstzzy.top/2023/12/08/vx_recycle_bin/20231208/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1.md/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1/</id>
    <published>2023-12-08T08:59:00.000Z</published>
    <updated>2023-12-08T09:35:44.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitGithub和Gitee的使用的使用"><a href="#GitGithub和Gitee的使用的使用" class="headerlink" title="GitGithub和Gitee的使用的使用"></a>GitGithub和Gitee的使用的使用</h1><p>廖老师的教程中关于github的使用的介绍比较少，可以参考<a href="https://blog.csdn.net/dangfulin/article/details/107868575?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-107868575-blog-128958918.235%5Ev39%5Epc_relevant_3m_sort_dl_base2&spm=1001.2101.3001.4242.1&utm_relevant_index=3">此链接</a>中更详细的教程。</p><p>Gitee的使用与Github的使用基本相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GitGithub和Gitee的使用的使用&quot;&gt;&lt;a href=&quot;#GitGithub和Gitee的使用的使用&quot; class=&quot;headerlink&quot; title=&quot;GitGithub和Gitee的使用的使用&quot;&gt;&lt;/a&gt;GitGithub和Gitee的使用的使用&lt;/</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git标签管理</title>
    <link href="http://cstzzy.top/2023/12/08/20%EF%BC%9Agit-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
    <id>http://cstzzy.top/2023/12/08/20%EF%BC%9Agit-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-08T08:25:00.000Z</published>
    <updated>2023-12-08T08:45:45.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git标签管理"><a href="#Git标签管理" class="headerlink" title="Git标签管理"></a>Git标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><pre class="highlight"><span class="line">git branch</span><br></pre><p>然后，敲命令<code>git tag &lt;tagname&gt;</code>就可以打一个新标签。<br>可以用命令<code>git tag</code>查看所有标签，用命令<code>git show &lt;tagname&gt;</code>查看标签信息。</p><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？<br>方法是找到历史提交的commit id，然后打上就可以了：<code>git tag &lt;tagname&gt; &lt;commit id&gt;</code></p><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><pre class="highlight"><span class="line">git tag -a &lt;tagname&gt; -m &quot;XXXXXX&quot; &lt;commit id&gt;</span><br></pre><p>如果标签打错了，也可以删除：</p><pre class="highlight"><span class="line">git tag -d &lt;tagname&gt;</span><br></pre><p>因为<strong>创建的标签都只存储在本地，不会自动推送到远程</strong>。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或者，一次性推送全部尚未推送到远程的本地标签<code>git push origin --tags</code>。</p><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre class="highlight"><span class="line">git tag -d &lt;tagname&gt;</span><br></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre class="highlight"><span class="line">git push origin :refs/tags/&lt;tagname&gt;</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git标签管理&quot;&gt;&lt;a href=&quot;#Git标签管理&quot; class=&quot;headerlink&quot; title=&quot;Git标签管理&quot;&gt;&lt;/a&gt;Git标签管理&lt;/h1&gt;&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="http://cstzzy.top/2023/12/06/19%EF%BC%9Agit-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://cstzzy.top/2023/12/06/19%EF%BC%9Agit-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-06T11:53:00.000Z</published>
    <updated>2023-12-09T03:43:56.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>创建与合并分支的示意图见：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424#0">创建与合并分支</a></p><p>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch <name></p><p>切换分支：git checkout <name>或者git switch <name></p><p>创建+切换分支：git checkout -b <name>或者git switch -c <name></p><p>合并某分支到当前分支：git merge <name></p><p>删除分支：git branch -d <name></p><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用git log –graph命令可以看到分支合并图。</p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><p><strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136#0">Bug分支</a></strong></p><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900394246995648">Feature分支</a></p><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作</a></p><p>多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin <branch-name>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</p><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin&#x2F;<branch-name>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查看远程库信息，使用git remote -v；</p><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</p><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；</p><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p><p>注意：</p><ul><li><p>在进行<code>git pull</code>时可能会出现error: insufficient permission for adding an object to repository database .git&#x2F;objects，可参考<a href="https://blog.csdn.net/menglishuigui/article/details/123548275">此链接</a>解决。</p></li><li><p>进行<code>git pull</code>时会输出以下提示：</p><pre class="highlight"><span class="line">hint: You have divergent branches and need to specify how to reconcile them.</span><br><span class="line">hint: You can do so by running one of the following commands sometime before</span><br><span class="line">hint: your next pull:</span><br><span class="line">hint: </span><br><span class="line">hint:   git config pull.rebase false  # merge</span><br><span class="line">hint:   git config pull.rebase true   # rebase</span><br><span class="line">hint:   git config pull.ff only       # fast-forward only</span><br><span class="line">hint: </span><br><span class="line">hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default</span><br><span class="line">hint: preference for all repositories. You can also pass --rebase, --no-rebase,</span><br><span class="line">hint: or --ff-only on the command line to override the configured default per</span><br><span class="line">hint: invocation.</span><br></pre><p>改为使用<code>git config pull.rebase false</code>，再<code>git pull</code>即可。</p></li><li><p>在进行git checkout -b branch-name origin&#x2F;branch-name时可能会报错：fatal: ‘origin&#x2F;dev’ is not a commit and a branch ‘dev’ cannot be created from it，可参考<a href="https://blog.csdn.net/leyangjun/article/details/130282665">此链接</a>解决。</p></li></ul><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648">Rebase</a>没太看懂举的例子，但是知道rebase操作的作用。</p><ul><li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git分支管理&quot;&gt;&lt;a href=&quot;#Git分支管理&quot; class=&quot;headerlink&quot; title=&quot;Git分支管理&quot;&gt;&lt;/a&gt;Git分支管理&lt;/h1&gt;&lt;p&gt;分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git远程仓库</title>
    <link href="http://cstzzy.top/2023/12/06/18%EF%BC%9Agit-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://cstzzy.top/2023/12/06/18%EF%BC%9Agit-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2023-12-06T09:14:00.000Z</published>
    <updated>2023-12-06T11:50:59.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><ul><li>在GitHub中创建一个名为learngit的仓库；</li><li>在<mark>本地的learngit仓库</mark>下运行命令： <pre class="highlight"><span class="line">$ git remote add origin https://github.com/CSTZZY/learngit.git</span><br></pre>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</li><li>把本地库的所有内容推送到远程库上：<pre class="highlight"><span class="line">git push -u origin main</span><br></pre>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</li></ul><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><ul><li>从现在起，只要本地作了提交，就可以通过命令：<pre class="highlight"><span class="line">git push -u origin main</span><br></pre>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</li></ul><p>如果你想删除远程库，可以先使用：<code>git remote -v</code>查看远程库的信息，然后根据远程库的名称使用<code>git remote rm origin</code>删除远程库。</p><p><strong>注意：此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</strong></p><p>以上内容为先有本地库，后有远程库时，怎么关联远程库。<br>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills，并勾选Initialize this repository with a README。</p><p>下一步是用命令git clone克隆一个本地库：</p><pre class="highlight"><span class="line">git clone git@github.com:CSTZZY/gitskills.git</span><br><span class="line">或者</span><br><span class="line">git clone https://github.com/CSTZZY/gitskills.git</span><br></pre><p>GitHub给出的地址不止一个。实际上，Git支持多种协议，<a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:CSTZZY&#x2F;gitskills.git使用ssh，但也可以使用https（如：<a href="https://github.com/CSTZZY/gitskills.git%EF%BC%89%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82">https://github.com/CSTZZY/gitskills.git）等其他协议。</a></p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><p>Git支持多种协议，包括https，但ssh协议速度最快。</p><p>这里对git push的讲解不是很全面，可以参考：<a href="https://blog.csdn.net/qq_37049311/article/details/127932396">https://blog.csdn.net/qq_37049311&#x2F;article&#x2F;details&#x2F;127932396</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git远程仓库&quot;&gt;&lt;a href=&quot;#Git远程仓库&quot; class=&quot;headerlink&quot; title=&quot;Git远程仓库&quot;&gt;&lt;/a&gt;Git远程仓库&lt;/h1&gt;&lt;p&gt;为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git删除文件</title>
    <link href="http://cstzzy.top/2023/12/05/17%EF%BC%9Agit-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"/>
    <id>http://cstzzy.top/2023/12/05/17%EF%BC%9Agit-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</id>
    <published>2023-12-05T13:39:00.000Z</published>
    <updated>2023-12-05T13:43:31.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git删除文件"><a href="#Git删除文件" class="headerlink" title="Git删除文件"></a>Git删除文件</h1><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><pre class="highlight"><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p><pre class="highlight"><span class="line">$ rm test.txt</span><br></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p><pre class="highlight"><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p><pre class="highlight"><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre><p>现在，文件就从版本库中被删除了。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre class="highlight"><span class="line">$ git checkout -- test.txt</span><br></pre><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p> 注意：从来没有被添加（git add）到版本库就被删除的文件，是无法恢复的！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git删除文件&quot;&gt;&lt;a href=&quot;#Git删除文件&quot; class=&quot;headerlink&quot; title=&quot;Git删除文件&quot;&gt;&lt;/a&gt;Git删除文件&lt;/h1&gt;&lt;p&gt;在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：&lt;</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git管理与撤销修改</title>
    <link href="http://cstzzy.top/2023/12/05/16%EF%BC%9Agit-%E7%AE%A1%E7%90%86%E4%B8%8E%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/"/>
    <id>http://cstzzy.top/2023/12/05/16%EF%BC%9Agit-%E7%AE%A1%E7%90%86%E4%B8%8E%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</id>
    <published>2023-12-05T13:10:00.000Z</published>
    <updated>2023-12-06T01:03:27.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git管理与撤销修改"><a href="#Git管理与撤销修改" class="headerlink" title="Git管理与撤销修改"></a>Git管理与撤销修改</h1><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>进行实验验证git管理的是修改：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p><p>按照上述过程操作，你会发现第二次的修改并没有被提交，这是因为Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时（没有进行git add 和 git commit），用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（仅使用了git add），想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时（已经使用了git add 和 git commit），想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><p>注意：</p><ul><li>当使用git status查看git状态时，如果提示Changes not staged for commit，这表示没有使用git add，如果提示Changes to be committed，这表明已经使用git add将修改添加到了暂存取但没有使用git commit提交修改。</li><li>先手动删除文件，然后使用git rm &lt;file&gt;和git add &lt;file&gt;效果是一样的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git管理与撤销修改&quot;&gt;&lt;a href=&quot;#Git管理与撤销修改&quot; class=&quot;headerlink&quot; title=&quot;Git管理与撤销修改&quot;&gt;&lt;/a&gt;Git管理与撤销修改&lt;/h1&gt;&lt;h2 id=&quot;管理修改&quot;&gt;&lt;a href=&quot;#管理修改&quot; class=&quot;head</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git工作区和暂存区</title>
    <link href="http://cstzzy.top/2023/12/02/15%EF%BC%9Agit-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/"/>
    <id>http://cstzzy.top/2023/12/02/15%EF%BC%9Agit-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/</id>
    <published>2023-12-02T11:49:00.000Z</published>
    <updated>2023-12-02T12:30:16.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git工作区和暂存区"><a href="#Git工作区和暂存区" class="headerlink" title="Git工作区和暂存区"></a>Git工作区和暂存区</h1><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>工作区（Working Directory）：就是你在电脑里能看到的目录。<br>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>下图可以形象的解释<code>git add</code>和<code>git commit</code>的作用：<br><img src="/vx_images/269463611626088" alt="0" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/269463611626088" class="lozad post-image"><br>把文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git工作区和暂存区&quot;&gt;&lt;a href=&quot;#Git工作区和暂存区&quot; class=&quot;headerlink&quot; title=&quot;Git工作区和暂存区&quot;&gt;&lt;/a&gt;Git工作区和暂存区&lt;/h1&gt;&lt;p&gt;Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。&lt;br&gt;工</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题3</title>
    <link href="http://cstzzy.top/2023/12/02/14%EF%BC%9ALeetCode%E7%83%AD%E9%A2%983/"/>
    <id>http://cstzzy.top/2023/12/02/14%EF%BC%9ALeetCode%E7%83%AD%E9%A2%983/</id>
    <published>2023-12-02T09:28:00.000Z</published>
    <updated>2024-01-03T11:19:37.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">最长连续序列</a></h1><p>首先介绍一开始我自己的想的方法，然后再介绍官方题解。</p><h2 id="方法一：我的方法"><a href="#方法一：我的方法" class="headerlink" title="方法一：我的方法"></a>方法一：我的方法</h2><p>思路及算法：</p><p>首先对数组进行排序，并去重，然后从第一个元素向后匹配，注意：每个数仅遍历1次，下一次匹配的起点为当前匹配的终点的后一个元素。如果不算排序加去重的时间复杂度，那么这个方法的时间复杂度刚好为$O(N)$。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==0)</span><br><span class="line">            return 0;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        unique(nums.begin(),nums.end());</span><br><span class="line">        int res=1;</span><br><span class="line">        int temp=1;</span><br><span class="line">        for(int i=0;i&lt;nums.size()-1;i++)&#123;</span><br><span class="line">            while(i&lt;(nums.size()-1)&amp;&amp;(nums[i+1]==(nums[i]+1)))&#123;</span><br><span class="line">                temp++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp&gt;res)</span><br><span class="line">                res=temp;</span><br><span class="line">            temp=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; num_set;</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int num:num_set)&#123;</span><br><span class="line">            if(!num_set.count(num-1))&#123;</span><br><span class="line">                int cur_num=num;</span><br><span class="line">                int temp=1;</span><br><span class="line">                while(num_set.count(cur_num+1))&#123;</span><br><span class="line">                    cur_num++;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp&gt;res)</span><br><span class="line">                    res=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>这个方法的运行时间为128ms，而我的方法运行时间只有80ms。</p><p>注意：在leetcode中提交带有数组下标是否越界判断的语句时，如果先判断arr[i] &lt; arr[i+1]，再判断(i+1)&lt;&#x3D;len，这里i+1可能已经越界了，会导致此错误，需要改为先判断(i+1)&lt;&#x3D;len，再判断arr[i] &lt; arr[i+1]。<br>参考链接： <a href="https://blog.csdn.net/adoge_/article/details/129072054">https://blog.csdn.net/adoge_/article/details/129072054</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最长连续序列&quot;&gt;&lt;a href=&quot;#最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;最长连续序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-consecutive-sequence/?</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>在本地部署Overleaf</title>
    <link href="http://cstzzy.top/2023/12/01/13%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Overleaf/"/>
    <id>http://cstzzy.top/2023/12/01/13%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Overleaf/</id>
    <published>2023-12-01T12:22:00.000Z</published>
    <updated>2023-12-02T03:15:41.754Z</updated>
    
    <content type="html"><![CDATA[<p>一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。</p><ol><li>安装Docker Desktop </br> <a href="https://www.docker.com/products/docker-desktop/">Docker官网</a> </br> <a href="https://blog.csdn.net/rongtaoup/article/details/131263235">安装教程</a></li><li>使用Docker安装Overleaf</li></ol><ul><li><p>打开命令行cmd， 拉取 Overleaf 官方开源镜像，<a href="https://github.com/overleaf/overleaf/wiki/Release-Notes--4.x.x">Overleaf版本参考地址</a>：</p><pre class="highlight"><span class="line">docker pull sharelatex/sharelatex:4.1.6</span><br></pre><p>由于国内下载比较慢，需要等待挺长时间，可以参照 <a href="https://www.cnblogs.com/Flat-White/p/17107494.html">https://www.cnblogs.com/Flat-White/p/17107494.html</a> 设置国内的Docker源。</p></li><li><p>前往 <a href="https://github.com/overleaf/overleaf/blob/main/docker-compose.yml">https://github.com/overleaf/overleaf/blob/main/docker-compose.yml</a> 下载 docker-compose.yml 文件到本地；</p></li><li><p>对下载下来的docker-compose.yml 进行如下修改：<br>(1): 将image: sharelatex&#x2F;sharelatex的版本修改为：</p><pre class="highlight"><span class="line">image: sharelatex/sharelatex:4.1.6</span><br></pre><p>(2): 将mongo部分的配置修改成如下所示：</p> <pre class="highlight"><span class="line">mongo:</span><br><span class="line">     restart: always</span><br><span class="line">     image: mongo:4.4</span><br><span class="line">     container_name: mongo</span><br><span class="line">     command: &quot;--replSet overleaf&quot;</span><br><span class="line">     expose:</span><br><span class="line">       - 27017</span><br><span class="line">     volumes:</span><br><span class="line">       - &quot;./mongo_data:/data/db&quot;</span><br><span class="line">     healthcheck:</span><br><span class="line">       test: echo &#x27;db.stats().ok&#x27; | mongo localhost:27017/test --quiet</span><br><span class="line">       interval: 10s</span><br><span class="line">       timeout: 10s</span><br><span class="line">       retries: 5</span><br><span class="line"></span><br><span class="line"> mongoinit:</span><br><span class="line">     image: mongo:4.4</span><br><span class="line">     # this container will exit after executing the command</span><br><span class="line">     restart: &quot;no&quot;</span><br><span class="line">     depends_on:</span><br><span class="line">       mongo:</span><br><span class="line">         condition: service_healthy</span><br><span class="line">     entrypoint:</span><br><span class="line">       [</span><br><span class="line">         &quot;mongo&quot;,</span><br><span class="line">         &quot;--host&quot;,</span><br><span class="line">         &quot;mongo:27017&quot;,</span><br><span class="line">         &quot;--eval&quot;,</span><br><span class="line">         &#x27;rs.initiate(&#123; _id: &quot;overleaf&quot;, members: [ &#123; _id: 0, host: &quot;mongo:27017&quot; &#125; ] &#125;)&#x27;,</span><br><span class="line">       ]</span><br></pre></li><li><p>命令行进入docker-compose.yml 文件所在目录下，然后执行：</p><pre class="highlight"><span class="line">docker-compose up</span><br></pre></li></ul><ol start="3"><li>通过访问<a href="http://127.0.0.1/launchpad">http://127.0.0.1/launchpad</a> 可以配置管理员账号。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装Docker Desktop &lt;/br&gt; &lt;a href=&quot;https://www.docker.com/products/docker-desktop/&quot;&gt;Docker</summary>
      
    
    
    
    <category term="Overleaf" scheme="http://cstzzy.top/categories/Overleaf/"/>
    
    
    <category term="Overleaf" scheme="http://cstzzy.top/tags/Overleaf/"/>
    
  </entry>
  
  <entry>
    <title>Git版本回退</title>
    <link href="http://cstzzy.top/2023/11/27/12%EF%BC%9Agit-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
    <id>http://cstzzy.top/2023/11/27/12%EF%BC%9Agit-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</id>
    <published>2023-11-27T08:28:00.000Z</published>
    <updated>2023-12-01T12:15:29.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git版本回退"><a href="#Git版本回退" class="headerlink" title="Git版本回退"></a>Git版本回退</h1><p><code>git log</code>命令显示从最近到最远的提交日志</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><ol><li>回退到上一个版本：<code>git reset --hard HEAD^</code></li><li>如果我想恢复到回退前的版本呢？也可以的！只要有回退前版本的<code>commit id</code>就好了：<code>git reset --hard &lt;commit id&gt;</code></li></ol><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本的时候，Git仅需要改变HEAD的指向，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><p>现在回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><pre class="highlight"><span class="line">8ddffe0 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to 8ddffe0c55</span><br><span class="line">0c21810 HEAD@&#123;1&#125;: reset: moving to 0c218101</span><br><span class="line">c40f97b HEAD@&#123;2&#125;: reset: moving to HEAD^</span><br><span class="line">0c21810 HEAD@&#123;3&#125;: reset: moving to HEAD^</span><br><span class="line">8ddffe0 (HEAD -&gt; main) HEAD@&#123;4&#125;: commit: append GPL</span><br><span class="line">0c21810 HEAD@&#123;5&#125;: commit: add ds</span><br><span class="line">c40f97b HEAD@&#123;6&#125;: commit: add distributed</span><br><span class="line">3c16155 HEAD@&#123;7&#125;: commit (initial): wrote a readme file</span><br></pre><p>从上述输出可以知道“append GPL”的<code>commit id</code>为8ddffe0，因此使用<code>git reset --hard 8ddffe0</code>即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在总结一下：</p><ol><li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git版本回退&quot;&gt;&lt;a href=&quot;#Git版本回退&quot; class=&quot;headerlink&quot; title=&quot;Git版本回退&quot;&gt;&lt;/a&gt;Git版本回退&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;命令显示从最近到最远的提交日志&lt;/p&gt;
&lt;p&gt;首先，Git必</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题2</title>
    <link href="http://cstzzy.top/2023/11/26/11%EF%BC%9ALeetCode%E7%83%AD%E9%A2%982/"/>
    <id>http://cstzzy.top/2023/11/26/11%EF%BC%9ALeetCode%E7%83%AD%E9%A2%982/</id>
    <published>2023-11-26T12:25:00.000Z</published>
    <updated>2023-11-26T12:38:00.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></h1><p>前言<br>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键。</p><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>思路及算法：</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; mp;</span><br><span class="line">        for(string&amp; str:strs)&#123;</span><br><span class="line">            string key=str;</span><br><span class="line">            sort(key.begin(),key.end());</span><br><span class="line">            mp[key].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        for(auto it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">            res.push_back(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>复杂度分析</p><p>时间复杂度：$O(nk\log⁡k)$，其中 n 是 strs 中的字符串的数量，k是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 $O(k \log k)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nk \log k)$。</p><p>空间复杂度：$O(nk)$，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><p>注意：向vector添加元素有两种方法：push_back()和emplace_back()，要了解<a href="https://c.biancheng.net/view/6826.html">它们的区别</a>。</p><h2 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h2><p>没有第一种方法好，因此不详述，想了解可以去查看官方题解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;字母异位词分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagrams/?envType=stu</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题1</title>
    <link href="http://cstzzy.top/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/"/>
    <id>http://cstzzy.top/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/</id>
    <published>2023-11-26T11:28:00.000Z</published>
    <updated>2023-11-27T05:12:58.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked">两数之和</a></h1><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><p>思路及算法：</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        for(int i=0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if((nums[i]+nums[j])==target)</span><br><span class="line">                    return &#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>复杂度分析</p><p>时间复杂度：$O(N^2)$，其中N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p><p>空间复杂度：$O(1)$。</p><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>思路及算法：</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; hashtable;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            auto it=hashtable.find(target-nums[i]);</span><br><span class="line">            if(it!=hashtable.end())&#123;</span><br><span class="line">                return &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>注意：这里用到了C++中的容器：<a href="https://blog.csdn.net/hk2291976/article/details/51037095">unordered_map</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/description/?envType=study-p</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>Git查看修改内容与仓库状态</title>
    <link href="http://cstzzy.top/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/"/>
    <id>http://cstzzy.top/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/</id>
    <published>2023-11-23T13:38:00.000Z</published>
    <updated>2023-11-23T14:20:53.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git查看修改内容与仓库状态"><a href="#Git查看修改内容与仓库状态" class="headerlink" title="Git查看修改内容与仓库状态"></a>Git查看修改内容与仓库状态</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件（在第一行插入单词”distributed”），改成如下内容：</p><pre class="highlight"><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre><p>现在，运行git status命令看看结果：</p><pre class="highlight"><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br></pre><p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：</p><pre class="highlight"><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index d8036c1..013b5bc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre><p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p><p>因为之前没有了解过Unix的diff命令的输出格式，因此去查了一下，记录如下：</p><p>上面展示的<code>git diff</code>的输出结果是合并格式的diff，除此之外还有其它两种格式（参考：<a href="https://blog.csdn.net/qq_37179197/article/details/97649845">Unix系统的diff工具程序</a>）。</p><pre class="highlight"><span class="line">diff --git a/readme.txt b/readme.txt</span><br></pre><p>表示进行比较的是，a版本的readme.txt（即变动前）和b版本的readme.txt（即变动后）。</p><pre class="highlight"><span class="line">index d8036c1..013b5bc 100644</span><br></pre><p>第二行表示两个版本的git哈希值（index区域的d8036c1对象，与工作目录区域的013b5bc对象进行比较），100644是对象的模式（普通文件，644权限）。</p><pre class="highlight"><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br></pre><p>表示文件的基本信息，“—”表示变动前的文件,”+++”表示变动后的文件。</p><pre class="highlight"><span class="line">@@ -1,2 +1,2 @@</span><br></pre><p>变动的位置用两个@作为起首和结束。</p><p><code>-1,2</code>分成三个部分：减号表示变动前的文件，”1”表示第1行，“2”表示连续2行。合在一起，就表示下面是变动前的文件从第1行开始的连续2行。同样的，”+1,2”表示变动后的文件从第1行开始的连续2行。</p><p>最后除了有变动的那些行以外，还将两个文件的上下文合并显示在一起，所以叫做”合并格式”。每一行最前面的标志位，空表示无变动，减号表示变动前的文件删除的行，加号表示变动后的文件新增的行。</p><p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：</p><pre class="highlight"><span class="line">git add readme.txt</span><br></pre><p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：</p><pre class="highlight"><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   readme.txt</span><br></pre><p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：</p><pre class="highlight"><span class="line">git commit -m &quot;add distributed&quot;</span><br></pre><p>提交后，我们再用git status命令看看仓库的当前状态：</p><pre class="highlight"><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li><li>上述例子仅展示了使用git add跟踪一个文件，还可以继续使用git add命令添加要跟踪的文件，之后如果修改了多个跟踪文件，则使用git diff时会分别显示各个文件的diff。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git查看修改内容与仓库状态&quot;&gt;&lt;a href=&quot;#Git查看修改内容与仓库状态&quot; class=&quot;headerlink&quot; title=&quot;Git查看修改内容与仓库状态&quot;&gt;&lt;/a&gt;Git查看修改内容与仓库状态&lt;/h1&gt;&lt;p&gt;我们已经成功地添加并提交了一个readme.</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git创建版本库</title>
    <link href="http://cstzzy.top/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <id>http://cstzzy.top/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</id>
    <published>2023-11-23T13:04:00.000Z</published>
    <updated>2023-11-28T13:45:39.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre class="highlight"><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br></pre><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><pre class="highlight"><span class="line">git init</span><br></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>编写一个readme.txt文件，内容如下：</p><pre class="highlight"><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><pre class="highlight"><span class="line">git add readme.txt</span><br></pre><p>使用<code>git add .</code>可以一次性添加所有修改。</p><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><pre class="highlight"><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件（到暂存区），比如：</p><pre class="highlight"><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m &quot;add 3 files.&quot;</span><br></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令git add <file>，注意，可反复多次使用，添加多个文件；<br>使用命令git commit -m <message>，完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git创建版本库&quot;&gt;&lt;a href=&quot;#Git创建版本库&quot; class=&quot;headerlink&quot; title=&quot;Git创建版本库&quot;&gt;&lt;/a&gt;Git创建版本库&lt;/h1&gt;&lt;p&gt;版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git简介</title>
    <link href="http://cstzzy.top/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/"/>
    <id>http://cstzzy.top/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/</id>
    <published>2023-11-23T12:27:00.000Z</published>
    <updated>2023-11-23T12:56:14.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p><p>集中式版本控制系统：版本库集中存放在中央服务器，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/10974702836917" class="lozad post-image"src="/vx_images/10974702836917"></p><p>分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个完整的版本库，因此分布式比集中式安全：某台电脑坏了仅需要从其它电脑复制一份版本库即可，而中央服务器坏了就无法找回版本库了。利用分布式版本控制系统工作时就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/222346411626009" class="lozad post-image"src="/vx_images/222346411626009"></p><p>Git的优点：无需联网、分布式、强大的分制管理。<br>其它免费版本控制系统：</p><ul><li>CVS：最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。</li><li>SVN：修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</li></ul><p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p><p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p><p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p><p>了解完Git后下一步应该开始安装Git，但是MacBook已经安装了git，因此pass。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h1&gt;&lt;p&gt;CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;集中式版本控制系统：版本库集中</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cstzzy.top/2023/11/23/vx/"/>
    <id>http://cstzzy.top/2023/11/23/vx/</id>
    <published>2023-11-23T11:55:09.229Z</published>
    <updated>2024-01-03T11:19:37.813Z</updated>
    
    <content type="html"><![CDATA[{"created_time":"2023-11-23T11:55:09Z","files":[{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"2","modified_time":"2023-11-23T12:01:59Z","name":"1：hexo初级搭建、github page部署及个人域名绑定.md","signature":"784285914990853533","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"3","modified_time":"2023-11-23T11:55:09Z","name":"2：hexo的基本配置、更换主题.md","signature":"5546498803292388765","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"4","modified_time":"2023-11-23T11:55:09Z","name":"3：给个人博客添加RSS.md","signature":"8223662518592028061","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"5","modified_time":"2023-11-23T11:55:09Z","name":"4：给个人博客添加评论系统.md","signature":"8927815552003423645","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"6","modified_time":"2023-11-23T11:55:09Z","name":"5：c++中的int*, int *&.md","signature":"1749579338025483677","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"7","modified_time":"2023-11-26T10:37:43Z","name":"6：排序算法总结.md","signature":"4749813615771467165","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"12","modified_time":"2023-11-23T12:56:14Z","name":"7：git-简介.md","signature":"207324067087533","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"11","modified_time":"2023-11-28T13:45:39Z","name":"8：git-创建版本库.md","signature":"8223662518592031744","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"14","modified_time":"2023-11-23T14:20:53Z","name":"9：git-查看修改内容与仓库状态.md","signature":"8927815552003429748","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"17","modified_time":"2023-11-27T05:12:58Z","name":"10：LeetCode热题1.md","signature":"207324067343228","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"19","modified_time":"2023-11-26T12:38:00Z","name":"11：LeetCode热题2.md","signature":"784285914991114496","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"21","modified_time":"2023-12-01T12:15:29Z","name":"12：git-版本回退.md","signature":"207324067418869","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"24","modified_time":"2023-12-02T03:15:41Z","name":"13：在本地部署Overleaf.md","signature":"207324067778492","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"26","modified_time":"2024-01-03T11:19:37Z","name":"14：LeetCode热题3.md","signature":"207324067854486","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"28","modified_time":"2023-12-02T12:30:16Z","name":"15：git-工作区和暂存区.md","signature":"784285914991630751","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"30","modified_time":"2023-12-06T01:03:27Z","name":"16：git-管理与撤销修改.md","signature":"207324068127003","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"32","modified_time":"2023-12-05T13:43:31Z","name":"17：git-删除文件.md","signature":"784285914991896562","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"34","modified_time":"2023-12-06T11:50:59Z","name":"18：git-远程仓库.md","signature":"207324068199273","tags":[]},{"attachment_folder":"238732412626092","created_time":"2023-11-23T12:25:17Z","id":"36","modified_time":"2023-12-09T03:43:56Z","name":"19：git-分支管理.md","signature":"784285914991976579","tags":[]},{"attachment_folder":"238732412626092_1","created_time":"2023-11-23T12:25:17Z","id":"38","modified_time":"2023-12-08T08:45:45Z","name":"20：git-标签管理.md","signature":"207324068369132","tags":[]},{"attachment_folder":"238732412626092_1_1","created_time":"2023-11-23T12:25:17Z","id":"41","modified_time":"2023-12-08T09:35:44Z","name":"21：git-github和Gitee的使用.md","signature":"784285914992138967","tags":[]},{"attachment_folder":"238732412626092_1_2","created_time":"2023-11-23T12:25:17Z","id":"43","modified_time":"2023-12-08T11:20:59Z","name":"22：git-自定义git.md","signature":"784285914992145164","tags":[]},{"attachment_folder":"238732412626092_1_2_1","created_time":"2023-11-23T12:25:17Z","id":"45","modified_time":"2023-12-08T11:25:05Z","name":"23：git-使用SourceTree.md","signature":"5546498803293682881","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"47","modified_time":"2023-12-10T09:28:45Z","name":"24：LeetCode热题4.md","signature":"207324068521812","tags":[]}],"folders":[],"id":"1","modified_time":"2023-11-23T11:55:09Z","signature":"207324067085725","version":3}]]></content>
    
    
      
      
    <summary type="html">{&quot;created_time&quot;:&quot;2023-11-23T11:55:09Z&quot;,&quot;files&quot;:[{&quot;attachment_folder&quot;:&quot;&quot;,&quot;created_time&quot;:&quot;2023-11-23T11:55:09Z&quot;,&quot;id&quot;:&quot;2&quot;,&quot;modified_time&quot;:&quot;2023</summary>
      
    
    
    
    
  </entry>
  
</feed>
