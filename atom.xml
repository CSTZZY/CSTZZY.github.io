<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CSTZZY</title>
  
  <subtitle>个人主页</subtitle>
  <link href="http://cstzzy.top/atom.xml" rel="self"/>
  
  <link href="http://cstzzy.top/"/>
  <updated>2023-12-02T12:30:16.075Z</updated>
  <id>http://cstzzy.top/</id>
  
  <author>
    <name>ZZY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git工作区和暂存区</title>
    <link href="http://cstzzy.top/2023/12/02/15%EF%BC%9Agit-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/"/>
    <id>http://cstzzy.top/2023/12/02/15%EF%BC%9Agit-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/</id>
    <published>2023-12-02T11:49:00.000Z</published>
    <updated>2023-12-02T12:30:16.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git工作区和暂存区"><a href="#Git工作区和暂存区" class="headerlink" title="Git工作区和暂存区"></a>Git工作区和暂存区</h1><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>工作区（Working Directory）：就是你在电脑里能看到的目录。<br>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>下图可以形象的解释<code>git add</code>和<code>git commit</code>的作用：<br><img src="/vx_images/269463611626088" alt="0" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/269463611626088" class="lozad post-image"><br>把文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git工作区和暂存区&quot;&gt;&lt;a href=&quot;#Git工作区和暂存区&quot; class=&quot;headerlink&quot; title=&quot;Git工作区和暂存区&quot;&gt;&lt;/a&gt;Git工作区和暂存区&lt;/h1&gt;&lt;p&gt;Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。&lt;br&gt;工</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题3</title>
    <link href="http://cstzzy.top/2023/12/02/14%EF%BC%9ALeetCode%E7%83%AD%E9%A2%983/"/>
    <id>http://cstzzy.top/2023/12/02/14%EF%BC%9ALeetCode%E7%83%AD%E9%A2%983/</id>
    <published>2023-12-02T09:28:00.000Z</published>
    <updated>2023-12-02T10:06:58.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">最长连续序列</a></h1><p>首先介绍一开始我自己的想的方法，然后再介绍官方题解。</p><h2 id="方法一：我的方法"><a href="#方法一：我的方法" class="headerlink" title="方法一：我的方法"></a>方法一：我的方法</h2><p>思路及算法：</p><p>首先对数组进行排序，并去重，然后从第一个元素向后匹配，注意：每个数仅遍历1次，下一次匹配的起点为当前匹配的终点的后一个元素。如果不算排序加去重的时间复杂度，那么这个方法的时间复杂度刚好为$O(N)$。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()==0)</span><br><span class="line">            return 0;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        unique(nums.begin(),nums.end());</span><br><span class="line">        int res=1;</span><br><span class="line">        int temp=1;</span><br><span class="line">        for(int i=0;i&lt;nums.size()-1;i++)&#123;</span><br><span class="line">            while(i&lt;(nums.size()-1)&amp;&amp;(nums[i+1]==(nums[i]+1)))&#123;</span><br><span class="line">                temp++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp&gt;res)</span><br><span class="line">                res=temp;</span><br><span class="line">            temp=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; num_set;</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int num:num_set)&#123;</span><br><span class="line">            if(!num_set.count(num-1))&#123;</span><br><span class="line">                int cur_num=num;</span><br><span class="line">                int temp=1;</span><br><span class="line">                while(num_set.count(cur_num+1))&#123;</span><br><span class="line">                    cur_num++;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp&gt;res)</span><br><span class="line">                    res=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>这个方法的运行时间为128ms，而我的方法运行时间只有80ms。</p><p>注意：在leetcode中提交带有数组下标是否越界判断的语句时，要先判断arr[i] &lt; arr[i+1]，再判断(i+1)&lt;&#x3D;len，这里i+1可能已经越界了，会导致此错误。<br>参考链接： <a href="https://blog.csdn.net/adoge_/article/details/129072054">https://blog.csdn.net/adoge_/article/details/129072054</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最长连续序列&quot;&gt;&lt;a href=&quot;#最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;最长连续序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-consecutive-sequence/?</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>在本地部署Overleaf</title>
    <link href="http://cstzzy.top/2023/12/01/13%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Overleaf/"/>
    <id>http://cstzzy.top/2023/12/01/13%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Overleaf/</id>
    <published>2023-12-01T12:22:00.000Z</published>
    <updated>2023-12-02T03:15:41.754Z</updated>
    
    <content type="html"><![CDATA[<p>一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。</p><ol><li>安装Docker Desktop </br> <a href="https://www.docker.com/products/docker-desktop/">Docker官网</a> </br> <a href="https://blog.csdn.net/rongtaoup/article/details/131263235">安装教程</a></li><li>使用Docker安装Overleaf</li></ol><ul><li><p>打开命令行cmd， 拉取 Overleaf 官方开源镜像，<a href="https://github.com/overleaf/overleaf/wiki/Release-Notes--4.x.x">Overleaf版本参考地址</a>：</p><pre class="highlight"><span class="line">docker pull sharelatex/sharelatex:4.1.6</span><br></pre><p>由于国内下载比较慢，需要等待挺长时间，可以参照 <a href="https://www.cnblogs.com/Flat-White/p/17107494.html">https://www.cnblogs.com/Flat-White/p/17107494.html</a> 设置国内的Docker源。</p></li><li><p>前往 <a href="https://github.com/overleaf/overleaf/blob/main/docker-compose.yml">https://github.com/overleaf/overleaf/blob/main/docker-compose.yml</a> 下载 docker-compose.yml 文件到本地；</p></li><li><p>对下载下来的docker-compose.yml 进行如下修改：<br>(1): 将image: sharelatex&#x2F;sharelatex的版本修改为：</p><pre class="highlight"><span class="line">image: sharelatex/sharelatex:4.1.6</span><br></pre><p>(2): 将mongo部分的配置修改成如下所示：</p> <pre class="highlight"><span class="line">mongo:</span><br><span class="line">     restart: always</span><br><span class="line">     image: mongo:4.4</span><br><span class="line">     container_name: mongo</span><br><span class="line">     command: &quot;--replSet overleaf&quot;</span><br><span class="line">     expose:</span><br><span class="line">       - 27017</span><br><span class="line">     volumes:</span><br><span class="line">       - &quot;./mongo_data:/data/db&quot;</span><br><span class="line">     healthcheck:</span><br><span class="line">       test: echo &#x27;db.stats().ok&#x27; | mongo localhost:27017/test --quiet</span><br><span class="line">       interval: 10s</span><br><span class="line">       timeout: 10s</span><br><span class="line">       retries: 5</span><br><span class="line"></span><br><span class="line"> mongoinit:</span><br><span class="line">     image: mongo:4.4</span><br><span class="line">     # this container will exit after executing the command</span><br><span class="line">     restart: &quot;no&quot;</span><br><span class="line">     depends_on:</span><br><span class="line">       mongo:</span><br><span class="line">         condition: service_healthy</span><br><span class="line">     entrypoint:</span><br><span class="line">       [</span><br><span class="line">         &quot;mongo&quot;,</span><br><span class="line">         &quot;--host&quot;,</span><br><span class="line">         &quot;mongo:27017&quot;,</span><br><span class="line">         &quot;--eval&quot;,</span><br><span class="line">         &#x27;rs.initiate(&#123; _id: &quot;overleaf&quot;, members: [ &#123; _id: 0, host: &quot;mongo:27017&quot; &#125; ] &#125;)&#x27;,</span><br><span class="line">       ]</span><br></pre></li><li><p>命令行进入docker-compose.yml 文件所在目录下，然后执行：</p><pre class="highlight"><span class="line">docker-compose up</span><br></pre></li></ul><ol start="3"><li>通过访问<a href="http://127.0.0.1/launchpad">http://127.0.0.1/launchpad</a> 可以配置管理员账号。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装Docker Desktop &lt;/br&gt; &lt;a href=&quot;https://www.docker.com/products/docker-desktop/&quot;&gt;Docker</summary>
      
    
    
    
    <category term="Overleaf" scheme="http://cstzzy.top/categories/Overleaf/"/>
    
    
    <category term="Overleaf" scheme="http://cstzzy.top/tags/Overleaf/"/>
    
  </entry>
  
  <entry>
    <title>Git版本回退</title>
    <link href="http://cstzzy.top/2023/11/27/12%EF%BC%9Agit-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
    <id>http://cstzzy.top/2023/11/27/12%EF%BC%9Agit-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</id>
    <published>2023-11-27T08:28:00.000Z</published>
    <updated>2023-12-01T12:15:29.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git版本回退"><a href="#Git版本回退" class="headerlink" title="Git版本回退"></a>Git版本回退</h1><p><code>git log</code>命令显示从最近到最远的提交日志</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><ol><li>回退到上一个版本：<code>git reset --hard HEAD^</code></li><li>如果我想恢复到回退前的版本呢？也可以的！只要有回退前版本的<code>commit id</code>就好了：<code>git reset --hard &lt;commit id&gt;</code></li></ol><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本的时候，Git仅需要改变HEAD的指向，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><p>现在回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><pre class="highlight"><span class="line">8ddffe0 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to 8ddffe0c55</span><br><span class="line">0c21810 HEAD@&#123;1&#125;: reset: moving to 0c218101</span><br><span class="line">c40f97b HEAD@&#123;2&#125;: reset: moving to HEAD^</span><br><span class="line">0c21810 HEAD@&#123;3&#125;: reset: moving to HEAD^</span><br><span class="line">8ddffe0 (HEAD -&gt; main) HEAD@&#123;4&#125;: commit: append GPL</span><br><span class="line">0c21810 HEAD@&#123;5&#125;: commit: add ds</span><br><span class="line">c40f97b HEAD@&#123;6&#125;: commit: add distributed</span><br><span class="line">3c16155 HEAD@&#123;7&#125;: commit (initial): wrote a readme file</span><br></pre><p>从上述输出可以知道“append GPL”的<code>commit id</code>为8ddffe0，因此使用<code>git reset --hard 8ddffe0</code>即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在总结一下：</p><ol><li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git版本回退&quot;&gt;&lt;a href=&quot;#Git版本回退&quot; class=&quot;headerlink&quot; title=&quot;Git版本回退&quot;&gt;&lt;/a&gt;Git版本回退&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;命令显示从最近到最远的提交日志&lt;/p&gt;
&lt;p&gt;首先，Git必</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题2</title>
    <link href="http://cstzzy.top/2023/11/26/11%EF%BC%9ALeetCode%E7%83%AD%E9%A2%982/"/>
    <id>http://cstzzy.top/2023/11/26/11%EF%BC%9ALeetCode%E7%83%AD%E9%A2%982/</id>
    <published>2023-11-26T12:25:00.000Z</published>
    <updated>2023-11-26T12:38:00.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></h1><p>前言<br>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键。</p><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>思路及算法：</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; mp;</span><br><span class="line">        for(string&amp; str:strs)&#123;</span><br><span class="line">            string key=str;</span><br><span class="line">            sort(key.begin(),key.end());</span><br><span class="line">            mp[key].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        for(auto it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">            res.push_back(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>复杂度分析</p><p>时间复杂度：$O(nk\log⁡k)$，其中 n 是 strs 中的字符串的数量，k是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 $O(k \log k)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nk \log k)$。</p><p>空间复杂度：$O(nk)$，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><p>注意：向vector添加元素有两种方法：push_back()和emplace_back()，要了解<a href="https://c.biancheng.net/view/6826.html">它们的区别</a>。</p><h2 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h2><p>没有第一种方法好，因此不详述，想了解可以去查看官方题解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字母异位词分组&quot;&gt;&lt;a href=&quot;#字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;字母异位词分组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/group-anagrams/?envType=stu</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode热题1</title>
    <link href="http://cstzzy.top/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/"/>
    <id>http://cstzzy.top/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/</id>
    <published>2023-11-26T11:28:00.000Z</published>
    <updated>2023-11-27T05:12:58.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked">两数之和</a></h1><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><p>思路及算法：</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        for(int i=0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if((nums[i]+nums[j])==target)</span><br><span class="line">                    return &#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>复杂度分析</p><p>时间复杂度：$O(N^2)$，其中N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p><p>空间复杂度：$O(1)$。</p><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>思路及算法：</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><pre class="highlight"><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; hashtable;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            auto it=hashtable.find(target-nums[i]);</span><br><span class="line">            if(it!=hashtable.end())&#123;</span><br><span class="line">                return &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre><p>注意：这里用到了C++中的容器：<a href="https://blog.csdn.net/hk2291976/article/details/51037095">unordered_map</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/description/?envType=study-p</summary>
      
    
    
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/categories/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="LeetCode热题100" scheme="http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>Git查看修改内容与仓库状态</title>
    <link href="http://cstzzy.top/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/"/>
    <id>http://cstzzy.top/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/</id>
    <published>2023-11-23T13:38:00.000Z</published>
    <updated>2023-11-23T14:20:53.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git查看修改内容与仓库状态"><a href="#Git查看修改内容与仓库状态" class="headerlink" title="Git查看修改内容与仓库状态"></a>Git查看修改内容与仓库状态</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件（在第一行插入单词”distributed”），改成如下内容：</p><pre class="highlight"><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre><p>现在，运行git status命令看看结果：</p><pre class="highlight"><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br></pre><p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：</p><pre class="highlight"><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index d8036c1..013b5bc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre><p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p><p>因为之前没有了解过Unix的diff命令的输出格式，因此去查了一下，记录如下：</p><p>上面展示的<code>git diff</code>的输出结果是合并格式的diff，除此之外还有其它两种格式（参考：<a href="https://blog.csdn.net/qq_37179197/article/details/97649845">Unix系统的diff工具程序</a>）。</p><pre class="highlight"><span class="line">diff --git a/readme.txt b/readme.txt</span><br></pre><p>表示进行比较的是，a版本的readme.txt（即变动前）和b版本的readme.txt（即变动后）。</p><pre class="highlight"><span class="line">index d8036c1..013b5bc 100644</span><br></pre><p>第二行表示两个版本的git哈希值（index区域的d8036c1对象，与工作目录区域的013b5bc对象进行比较），100644是对象的模式（普通文件，644权限）。</p><pre class="highlight"><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br></pre><p>表示文件的基本信息，“—”表示变动前的文件,”+++”表示变动后的文件。</p><pre class="highlight"><span class="line">@@ -1,2 +1,2 @@</span><br></pre><p>变动的位置用两个@作为起首和结束。</p><p><code>-1,2</code>分成三个部分：减号表示变动前的文件，”1”表示第1行，“2”表示连续2行。合在一起，就表示下面是变动前的文件从第1行开始的连续2行。同样的，”+1,2”表示变动后的文件从第1行开始的连续2行。</p><p>最后除了有变动的那些行以外，还将两个文件的上下文合并显示在一起，所以叫做”合并格式”。每一行最前面的标志位，空表示无变动，减号表示变动前的文件删除的行，加号表示变动后的文件新增的行。</p><p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：</p><pre class="highlight"><span class="line">git add readme.txt</span><br></pre><p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：</p><pre class="highlight"><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   readme.txt</span><br></pre><p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：</p><pre class="highlight"><span class="line">git commit -m &quot;add distributed&quot;</span><br></pre><p>提交后，我们再用git status命令看看仓库的当前状态：</p><pre class="highlight"><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li><li>上述例子仅展示了使用git add跟踪一个文件，还可以继续使用git add命令添加要跟踪的文件，之后如果修改了多个跟踪文件，则使用git diff时会分别显示各个文件的diff。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git查看修改内容与仓库状态&quot;&gt;&lt;a href=&quot;#Git查看修改内容与仓库状态&quot; class=&quot;headerlink&quot; title=&quot;Git查看修改内容与仓库状态&quot;&gt;&lt;/a&gt;Git查看修改内容与仓库状态&lt;/h1&gt;&lt;p&gt;我们已经成功地添加并提交了一个readme.</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git创建版本库</title>
    <link href="http://cstzzy.top/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <id>http://cstzzy.top/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</id>
    <published>2023-11-23T13:04:00.000Z</published>
    <updated>2023-11-28T13:45:39.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre class="highlight"><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br></pre><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><pre class="highlight"><span class="line">git init</span><br></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>编写一个readme.txt文件，内容如下：</p><pre class="highlight"><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><pre class="highlight"><span class="line">git add readme.txt</span><br></pre><p>使用<code>git add .</code>可以一次性添加所有修改。</p><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><pre class="highlight"><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件（到暂存区），比如：</p><pre class="highlight"><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m &quot;add 3 files.&quot;</span><br></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令git add <file>，注意，可反复多次使用，添加多个文件；<br>使用命令git commit -m <message>，完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git创建版本库&quot;&gt;&lt;a href=&quot;#Git创建版本库&quot; class=&quot;headerlink&quot; title=&quot;Git创建版本库&quot;&gt;&lt;/a&gt;Git创建版本库&lt;/h1&gt;&lt;p&gt;版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git简介</title>
    <link href="http://cstzzy.top/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/"/>
    <id>http://cstzzy.top/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/</id>
    <published>2023-11-23T12:27:00.000Z</published>
    <updated>2023-11-23T12:56:14.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。</p><p>集中式版本控制系统：版本库集中存放在中央服务器，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/10974702836917" class="lozad post-image"src="/vx_images/10974702836917"></p><p>分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个完整的版本库，因此分布式比集中式安全：某台电脑坏了仅需要从其它电脑复制一份版本库即可，而中央服务器坏了就无法找回版本库了。利用分布式版本控制系统工作时就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/vx_images/222346411626009" class="lozad post-image"src="/vx_images/222346411626009"></p><p>Git的优点：无需联网、分布式、强大的分制管理。<br>其它免费版本控制系统：</p><ul><li>CVS：最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。</li><li>SVN：修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</li></ul><p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p><p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p><p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p><p>了解完Git后下一步应该开始安装Git，但是MacBook已经安装了git，因此pass。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h1&gt;&lt;p&gt;CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;集中式版本控制系统：版本库集中</summary>
      
    
    
    
    <category term="git" scheme="http://cstzzy.top/categories/git/"/>
    
    
    <category term="git" scheme="http://cstzzy.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cstzzy.top/2023/11/23/vx/"/>
    <id>http://cstzzy.top/2023/11/23/vx/</id>
    <published>2023-11-23T11:55:09.229Z</published>
    <updated>2023-12-02T12:30:16.077Z</updated>
    
    <content type="html"><![CDATA[{"created_time":"2023-11-23T11:55:09Z","files":[{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"2","modified_time":"2023-11-23T12:01:59Z","name":"1：hexo初级搭建、github page部署及个人域名绑定.md","signature":"784285914990853533","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"3","modified_time":"2023-11-23T11:55:09Z","name":"2：hexo的基本配置、更换主题.md","signature":"5546498803292388765","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"4","modified_time":"2023-11-23T11:55:09Z","name":"3：给个人博客添加RSS.md","signature":"8223662518592028061","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"5","modified_time":"2023-11-23T11:55:09Z","name":"4：给个人博客添加评论系统.md","signature":"8927815552003423645","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"6","modified_time":"2023-11-23T11:55:09Z","name":"5：c++中的int*, int *&.md","signature":"1749579338025483677","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"7","modified_time":"2023-11-26T10:37:43Z","name":"6：排序算法总结.md","signature":"4749813615771467165","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"12","modified_time":"2023-11-23T12:56:14Z","name":"7：git-简介.md","signature":"207324067087533","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"11","modified_time":"2023-11-28T13:45:39Z","name":"8：git-创建版本库.md","signature":"8223662518592031744","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"14","modified_time":"2023-11-23T14:20:53Z","name":"9：git-查看修改内容与仓库状态.md","signature":"8927815552003429748","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"17","modified_time":"2023-11-27T05:12:58Z","name":"10：LeetCode热题1.md","signature":"207324067343228","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"19","modified_time":"2023-11-26T12:38:00Z","name":"11：LeetCode热题2.md","signature":"784285914991114496","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"21","modified_time":"2023-12-01T12:15:29Z","name":"12：git-版本回退.md","signature":"207324067418869","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"24","modified_time":"2023-12-02T03:15:41Z","name":"13：在本地部署Overleaf.md","signature":"207324067778492","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T11:55:09Z","id":"26","modified_time":"2023-12-02T10:06:58Z","name":"14：LeetCode热题3.md","signature":"207324067854486","tags":[]},{"attachment_folder":"","created_time":"2023-11-23T12:25:17Z","id":"28","modified_time":"2023-12-02T12:30:16Z","name":"15：git-工作区和暂存区.md","signature":"784285914991630751","tags":[]}],"folders":[],"id":"1","modified_time":"2023-11-23T11:55:09Z","signature":"207324067085725","version":3}]]></content>
    
    
      
      
    <summary type="html">{&quot;created_time&quot;:&quot;2023-11-23T11:55:09Z&quot;,&quot;files&quot;:[{&quot;attachment_folder&quot;:&quot;&quot;,&quot;created_time&quot;:&quot;2023-11-23T11:55:09Z&quot;,&quot;id&quot;:&quot;2&quot;,&quot;modified_time&quot;:&quot;2023</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cstzzy.top/2023/11/23/vx_notebook/vx_notebook/"/>
    <id>http://cstzzy.top/2023/11/23/vx_notebook/vx_notebook/</id>
    <published>2023-11-23T11:55:09.228Z</published>
    <updated>2023-11-23T11:55:09.229Z</updated>
    
    <content type="html"><![CDATA[{"attachment_folder":"vx_attachments","config_mgr":"vx.vnotex","created_time":"2023-11-23T11:55:09Z","description":"myblog","extra_configs":{},"history":[],"image_folder":"vx_images","name":"_posts","tag_graph":"","version":3,"version_controller":"dummy.vnotex"}]]></content>
    
    
      
      
    <summary type="html">{&quot;attachment_folder&quot;:&quot;vx_attachments&quot;,&quot;config_mgr&quot;:&quot;vx.vnotex&quot;,&quot;created_time&quot;:&quot;2023-11-23T11:55:09Z&quot;,&quot;description&quot;:&quot;myblog&quot;,&quot;extra_configs&quot;:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://cstzzy.top/2023/11/21/6%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://cstzzy.top/2023/11/21/6%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-11-21T14:21:00.000Z</published>
    <updated>2023-11-26T10:37:43.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对常见的排序算法进行总结"><a href="#对常见的排序算法进行总结" class="headerlink" title="对常见的排序算法进行总结"></a>对常见的排序算法进行总结</h2><table><thead><tr><th align="center">名称</th><th align="center">时间复杂度</th><th align="center">算法核心思想</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">桶排序（啊哈简化版）</td><td align="center">$O(m+n)$ <br> 其中，m为桶的个数，n为待排序数的个数</td><td align="center">比如有范围为 0-10 的数需要排序，则需要 11 个桶，每个桶 i 保存数字 i 出现的次数，然后遍历桶，按照桶 i 中存放的 i 出现的次数 k 输出 k 次 i。</td><td align="center">1. 时间复杂度较小。</td><td align="center">1. 比如需要对（姓名，得分）进行排序，使用桶排序无法知道各个分数对应的姓名；</td></tr><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$ <br> 其中n为待排序数的个数</td><td align="center">每次比较相邻的两个元素，如果顺序错误则交换这两个元素的顺序，且每一趟仅将一个元素归位，因此如果有 n 个数进行排序，则需要进行 n-1 趟操作。</td><td align="center">-</td><td align="center">1. 时间复杂度高。</td></tr><tr><td align="center">快速排序</td><td align="center">最大时间复杂度：$O(N^2)$ <br> 平均时间复杂度：$O(NlogN)$ <br> 其中n为待排序数的个数</td><td align="center">每次以最左边的数为基准点，然后设置左右两个指针(i, j)分别指向待排序片段的最左侧和最右侧，然后先将右指针向左移动直到找到小于基准点的数或者与i相遇，再将左指针向右移动直到找到大于基准点的数或者与j相遇，然后交换i和j指向的数，重复上述过程直到i和j相遇，此时交换i指向的数与基准点，然后再对基准点左右两侧的数组片段重复上述过程，直到最终的片段只剩余一个数。</td><td align="center">1. 平均时间复杂度较小； <br> 2. 空间复杂度较小，仅需要使用一个额外存储空间以进行数组元素交换。</td><td align="center">-</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对常见的排序算法进行总结&quot;&gt;&lt;a href=&quot;#对常见的排序算法进行总结&quot; class=&quot;headerlink&quot; title=&quot;对常见的排序算法进行总结&quot;&gt;&lt;/a&gt;对常见的排序算法进行总结&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;c</summary>
      
    
    
    
    <category term="ah算法" scheme="http://cstzzy.top/categories/ah%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="排序算法总结" scheme="http://cstzzy.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>c++中的int*, int *&amp;</title>
    <link href="http://cstzzy.top/2023/11/21/5%EF%BC%9Ac++%E4%B8%AD%E7%9A%84int*,%20int%20*&amp;/"/>
    <id>http://cstzzy.top/2023/11/21/5%EF%BC%9Ac++%E4%B8%AD%E7%9A%84int*,%20int%20*&amp;/</id>
    <published>2023-11-21T05:26:00.000Z</published>
    <updated>2023-11-21T15:30:26.470Z</updated>
    
    <content type="html"><![CDATA[<p>突然想起来之前本科学 C++的时候老师讲过<code>int*</code> 和<code>int *&amp;</code> 的区别，但是已经很多年没接触过了，现在回忆一下。</p><p><strong>示例代码：</strong></p><blockquote><pre class="highlight"><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a=&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b=&quot;</span>&lt;&lt;&amp;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *p=&amp;a;</span><br><span class="line">    <span class="type">int</span> *&amp;pt=p;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p=&quot;</span>&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p=&quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;p=&quot;</span>&lt;&lt;&amp;p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*&amp;p=&quot;</span>&lt;&lt;*&amp;p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pt=&quot;</span>&lt;&lt;pt&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;pt=&quot;</span>&lt;&lt;&amp;pt&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*&amp;pt=&quot;</span>&lt;&lt;*&amp;pt&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*&amp;a=&quot;</span>&lt;&lt;*&amp;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></blockquote><ul><li><p><code>int &amp;b=a;</code> 表示 b 是 a 的引用，简单来说，b 是 a 的别名，b 和 a 是同一个人，改变 b 也会改变 a，反之亦然，</p></li><li><p><code>int *&amp;pt=p;</code> 表示 pt 是指针 p 的引用，pt 和 p 是同一个人。</p></li><li><p><code>*&amp;p=p，*&amp;a=a</code> 即：*&amp;XXX 相当于取 XXX 地址里存的东西，那自然是 XXX 本身了。</p></li></ul><p><strong>输出：</strong></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/655c41dfc458853aefc3dda7.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/655c41dfc458853aefc3dda7.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;突然想起来之前本科学 C++的时候老师讲过&lt;code&gt;int*&lt;/code&gt; 和&lt;code&gt;int *&amp;amp;&lt;/code&gt; 的区别，但是已经很多年没接触过了，现在回忆一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="c++基础" scheme="http://cstzzy.top/categories/c-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++" scheme="http://cstzzy.top/tags/c/"/>
    
    <category term="指针" scheme="http://cstzzy.top/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人 hexo 博客（4）</title>
    <link href="http://cstzzy.top/2023/11/18/4%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://cstzzy.top/2023/11/18/4%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-11-18T13:27:00.000Z</published>
    <updated>2023-11-18T13:30:54.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考链接：https-zhuanlan-zhihu-com-p-350704151"><a href="#参考链接：https-zhuanlan-zhihu-com-p-350704151" class="headerlink" title="参考链接：https://zhuanlan.zhihu.com/p/350704151"></a>参考链接：<a href="https://zhuanlan.zhihu.com/p/350704151">https://zhuanlan.zhihu.com/p/350704151</a></h2><p>这里使用 valine 实现评论，官方网  <a href="https://link.zhihu.com/?target=https://leancloud.cn/">https://leancloud.cn/</a></p><p>进入控制台后点击左下角创建应用</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic1.zhimg.com/80/v2-495635ee224900cdbc25bb5c0e8b8d08_1440w.webp" class="lozad post-image"src="https://pic1.zhimg.com/80/v2-495635ee224900cdbc25bb5c0e8b8d08_1440w.webp"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用 Key，然后就能看到你的 APP ID 和 APP Key 了</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558bc6fc458853aef47afef.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558bc6fc458853aef47afef.jpg"></p><p>开启评论功能  <code>kaze/_config.yml</code></p><pre class="highlight"><span class="line">comment:</span><br><span class="line">  enable: true</span><br><span class="line">  type: valine # valine | gitalk | livere | disqus | we recommend valine</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">gitalk config details can see <span class="keyword">in</span> https://github.com/gitalk/gitalk/blob/master/readme-cn.md</span></span><br><span class="line">  valine:</span><br><span class="line">    appId: 你的appId</span><br><span class="line">    appKey: 你的appKey</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考链接：https-zhuanlan-zhihu-com-p-350704151&quot;&gt;&lt;a href=&quot;#参考链接：https-zhuanlan-zhihu-com-p-350704151&quot; class=&quot;headerlink&quot; title=&quot;参考链接：https</summary>
      
    
    
    
    <category term="搭建个人hexo博客" scheme="http://cstzzy.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="http://cstzzy.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人hexo博客（3）</title>
    <link href="http://cstzzy.top/2023/11/18/3%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/"/>
    <id>http://cstzzy.top/2023/11/18/3%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/</id>
    <published>2023-11-18T13:01:00.000Z</published>
    <updated>2023-11-18T13:13:02.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：什么是-RSS？"><a href="#1：什么是-RSS？" class="headerlink" title="1：什么是 RSS？"></a><strong>1：什么是 RSS？</strong></h2><p>RSS 也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。</p><h2 id="2：为什么要用-RSS？"><a href="#2：为什么要用-RSS？" class="headerlink" title="2：为什么要用 RSS？"></a><strong>2：为什么要用 RSS？</strong></h2><p>就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过 RSS 订阅它们，然后在 RSS 阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过 RSS 订阅他。</p><p>在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么 RSS 订阅值得你的拥有。</p><h2 id="3：添加-RSS-功能"><a href="#3：添加-RSS-功能" class="headerlink" title="3：添加 RSS 功能"></a><strong>3：添加 RSS 功能</strong></h2><p>先安装 RSS 插件</p><pre class="highlight"><span class="line">npm i hexo-generator-feed</span><br></pre><p>而后在你整个项目的<code>_config.yml</code>中找到 Extensions，添加：</p><pre class="highlight"><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Extensions</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RSS订阅</span></span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Feed Atom</span></span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br></pre><p>这个时候你的 RSS 链接就是 域名<code>/atom.xml</code>了。</p><p>所以，在主题配置文件中的这个<code>social links</code>，开启 RSS 的页面功能，这样你网站上就有那个像 wifi 一样符号的 RSS logo 了，注意空格。</p><pre class="highlight"><span class="line">rss: /atom.xml</span><br></pre><h2 id="4：如何关注-RSS？"><a href="#4：如何关注-RSS？" class="headerlink" title="4：如何关注 RSS？"></a><strong>4：如何关注 RSS？</strong></h2><p>首先，你需要一个 RSS 阅读器，在这里我推荐<code>inoreader</code>，宇宙第一 RSS 阅读器，而且中文支持的挺好。不过它没有 PC 端的程序，只有网页版，chrome 上有插件。在官网上用 google 账号或者自己注册账号登录，就可以开始你的关注之旅了。</p><p>每次需要关注某个博主时，就点开他的 RSS 链接，把链接复制到<code>inoreader</code>上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索<code>阮一峰</code>，应该就能出来了。</p><p>在安卓端，inoreader 也有下载，不过因为国内 google 是登录不了的，你需要在 inoreader 官网上把你的密码修改了，然后就可以用账户名和密码登录了。</p><p>在 IOS 端，没用过，好像是 reader 3 可以支持 inoreader 账户，还有个 readon 也不错，可以去试试。</p><p>⚠️：按照上述步骤配置后网站打不开了，最后也没找到原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1：什么是-RSS？&quot;&gt;&lt;a href=&quot;#1：什么是-RSS？&quot; class=&quot;headerlink&quot; title=&quot;1：什么是 RSS？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1：什么是 RSS？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;RSS 也就是订阅功能，你可以理解为类似与</summary>
      
    
    
    
    <category term="搭建个人hexo博客" scheme="http://cstzzy.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="http://cstzzy.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人 hexo 博客（2）</title>
    <link href="http://cstzzy.top/2023/11/18/2%EF%BC%9Ahexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E3%80%81%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/"/>
    <id>http://cstzzy.top/2023/11/18/2%EF%BC%9Ahexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E3%80%81%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/</id>
    <published>2023-11-18T12:31:00.000Z</published>
    <updated>2023-11-18T13:25:54.965Z</updated>
    
    <content type="html"><![CDATA[<p>将 hexo 部署到 github 后就要进入下一步部分了：hexo 配置与主题个性化。</p><h2 id="1：hexo-基本配置"><a href="#1：hexo-基本配置" class="headerlink" title="1：hexo 基本配置"></a><strong>1：hexo 基本配置</strong></h2><p>在文件根目录下的<code>_config.yml</code>，就是整个 hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/docs/configuration">官方的配置</a>描述。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a><strong>网站</strong></h3><p><strong>参数描述：</strong><code>title</code>网站标题<code>subtitle</code>网站副标题<code>description</code>网站描述<code>author</code>您的名字<code>language</code>网站使用的语言<code>timezone</code>网站时区。Hexo 默认使用您电脑的时区。<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</p><p>其中，<code>description</code>主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65589273c458853aef928c3a.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65589273c458853aef928c3a.jpg"></p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a><strong>网址</strong></h3><p><strong>参数描：</strong><code>url</code>网址<code>root</code>网站根目录<code>permalink</code>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式<code>permalink_defaults</code>永久链接中各部分的默认值</p><p>在这里，你需要把<code>url</code>改成你的网站域名。</p><p>permalink，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫 temp.md，那么这个时候他自动生成的地址就是<code>http://yoursite.com/2018/09/05/temp</code>。</p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 。</p><p><strong>参数结果：</strong><code>year/:month/:day/:title/</code>2013&#x2F;07&#x2F;14&#x2F;hello-world<code>:year-:month-:day-:title.html</code>2013-07-14-hello-world.html<code>:category/:title</code>foo&#x2F;bar&#x2F;hello-world</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/655892b3c458853aef9370aa.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/655892b3c458853aef9370aa.jpg"></p><p>再往下翻，中间这些都默认就好了。</p><pre class="highlight"><span class="line">theme: landscape</span><br><span class="line">​</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br></pre><p><code>theme</code>就是选择什么主题，也就是在<code>theme</code>这个文件夹下，在官网上有很多个主题，默认给你安装的是<a href="https://www.zhihu.com/search?q=lanscape&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:489125915%7D">lanscape</a>这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在<code>theme</code>文件夹下，再修改这个参数就可以了。</p><p>接下来这个<code>deploy</code>就是网站的部署的，<code>repo</code>就是仓库(<code>Repository</code>)的简写。<code>branch</code>选择仓库的哪个分支。这个在之前进行 github page 部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/655892e7c458853aef940e75.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/655892e7c458853aef940e75.jpg"></p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a><strong>Front-matter</strong></h3><p>Front-matter 是 md 文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><pre class="highlight"><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><p><strong>参数描述：</strong><code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><pre class="highlight"><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre><h3 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a><strong>layout（布局）</strong></h3><p>当你每一次使用代码：</p><pre class="highlight"><span class="line">hexo new paper</span><br></pre><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><p><strong>布局路径</strong><code>postsource/_postspagesourcedraftsource/_drafts</code></p><p>而 new 这个命令其实是：</p><pre class="highlight"><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre><p>只不过这个 layout 默认是 post 罢了。</p><h4 id="page"><a href="#page" class="headerlink" title="page"></a><strong>page</strong></h4><p>如果你想另起一页，那么可以使用</p><pre class="highlight"><span class="line">hexo new page board</span><br></pre><p>系统会自动给你在 source 文件夹下创建一个 board 文件夹，以及 board 文件夹中的 index.md，这样你访问的 board 对应的链接就是<code>http://xxx.xxx/board</code></p><h4 id="draft"><a href="#draft" class="headerlink" title="draft"></a><strong>draft</strong></h4><p>draft 是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><pre class="highlight"><span class="line">hexo new draft newpage</span><br></pre><p>这样会在 source&#x2F;_draft 中新建一个 newpage.md 文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><pre class="highlight"><span class="line">hexo server --draft</span><br></pre><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到 post 中，</p><pre class="highlight"><span class="line">hexo publish draft newpage</span><br></pre><p>就会自动把 newpage.md 发送到 post 中。</p><h2 id="2：更换主题"><a href="#2：更换主题" class="headerlink" title="2：更换主题"></a><strong>2：更换主题</strong></h2><p><a href="https://hexo.io/themes/">官网的主题中</a>，选择喜欢的主题进行修改，我选的是<a href="https://github.com/theme-kaze/hexo-theme-Kaze">Kaze </a>。</p><p>去 github 上下载主题：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558acfec458853aeffb9dd0.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558acfec458853aeffb9dd0.jpg"></p><p>然后把下载的文件解压后放到：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558ad27c458853aeffc4e33.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558ad27c458853aeffc4e33.jpg"></p><p>kaze 文件中也有一个<code>_config.yml</code>文件，这个文件用于配制主题，比如：</p><h3 id="menu（菜单栏）"><a href="#menu（菜单栏）" class="headerlink" title="menu（菜单栏）"></a><strong>menu（菜单栏）</strong></h3><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://picx.zhimg.com/80/v2-f7759c435dcc46d877312b0b2c8b8e7d_1440w.webp?source=2c26e567" class="lozad post-image"src="https://picx.zhimg.com/80/v2-f7759c435dcc46d877312b0b2c8b8e7d_1440w.webp?source=2c26e567"></p><p>其中，About 这个是找不到网页的，因为文章中没有 about 这个东西。如果想要的话，可以执行命令</p><pre class="highlight"><span class="line">hexo new page about</span><br></pre><p>它就会在根目录下<code>source</code>文件夹中新建了一个<code>about</code>文件夹，以及 index.md，在 index.md 中写上想要写的东西，就可以在网站上展示出来了。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558addbc458853aefff7ef0.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558addbc458853aefff7ef0.jpg"></p><p>如果想要自己再自定义一个菜单栏的选项，那么就</p><pre class="highlight"><span class="line">hexo new page yourdiy</span><br></pre><p>然后在主题配置文件的 menu 菜单栏添加一个 <code>Yourdiy : /yourdiy</code>，注意冒号后面要有空格，以及前面的空格要和 menu 中默认的保持整齐。然后在<code>languages</code>文件夹中，找到<code>zh-CN.yml</code>，在 index 中添加<code>yourdiy: &#39;中文意思&#39;</code>就可以显示中文了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将 hexo 部署到 github 后就要进入下一步部分了：hexo 配置与主题个性化。&lt;/p&gt;
&lt;h2 id=&quot;1：hexo-基本配置&quot;&gt;&lt;a href=&quot;#1：hexo-基本配置&quot; class=&quot;headerlink&quot; title=&quot;1：hexo 基本配置&quot;&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="搭建个人hexo博客" scheme="http://cstzzy.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="http://cstzzy.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人hexo博客（1）</title>
    <link href="http://cstzzy.top/2023/11/18/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <id>http://cstzzy.top/2023/11/18/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</id>
    <published>2023-11-18T04:10:00.000Z</published>
    <updated>2023-11-23T12:01:59.619Z</updated>
    
    <content type="html"><![CDATA[<p>记录搭建 hexo 博客的相关步骤，以备后续再次使用。文章参考链接：</p><ul><li><p><a href="https://www.zhihu.com/question/20463581/answer/489125915">https://www.zhihu.com/question/20463581/answer/489125915</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/443038323">https://zhuanlan.zhihu.com/p/443038323</a></p></li><li><p><a href="https://www.jianshu.com/p/87b70ec06c71">https://www.jianshu.com/p/87b70ec06c71</a></p><hr></li></ul><h2 id="Hexo-搭建步骤"><a href="#Hexo-搭建步骤" class="headerlink" title="Hexo 搭建步骤"></a><strong>Hexo 搭建步骤</strong></h2><ol><li><p>安装 Git（MacBook 自带 Git，因此跳过）</p></li><li><p>安装 Node.js（本科的时候做工程认证系统时安装过，因此跳过）</p></li><li><p>安装 Hexo</p></li><li><p>GitHub 创建个人仓库</p></li><li><p>生成 SSH 添加到 GitHub（官方从 2021 年 8 月 13 日开始，在对 Git 操作进行身份验证时将不再接受帐户密码，并要求使用基于令牌的身份验证）</p></li><li><p>将 hexo 部署到 GitHub</p></li><li><p>设置个人域名（阿里云）</p></li><li><p>发布文章</p></li></ol><h2 id="1：安装-Git-x20"><a href="#1：安装-Git-x20" class="headerlink" title="1：安装 Git&#x20;"></a><strong>1：安装 Git</strong>&#x20;</h2><p>MacBook 自带 Git，因此不需要安装。在这里记录一个学习 Git 的网站：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a>。</p><h2 id="2：安装-nodejs"><a href="#2：安装-nodejs" class="headerlink" title="2：安装 nodejs"></a><strong>2：安装 nodejs</strong></h2><p>本科的时候做工程认证系统时安装过，因此跳过。</p><h2 id="3：安装-hexo"><a href="#3：安装-hexo" class="headerlink" title="3：安装 hexo"></a><strong>3：安装 hexo</strong></h2><p>前面 git 和 nodejs 安装好后，就可以安装 hexo 了，先创建一个文件夹 myblog，然后<code>cd</code>到这个文件夹下。&#x20;</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/655842c6c458853aef6282dd.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/655842c6c458853aef6282dd.jpg"></p><p>输入命令：</p><pre class="highlight"><span class="line">npm install -g hexo-cli</span><br></pre><p>至此就全部安装完了。</p><p>接下来初始化 hexo：</p><pre class="highlight"><span class="line">hexo init myblog</span><br></pre><p>这个 myblog 可以自己取什么名字都行。</p><p>再安装相关依赖包：</p><pre class="highlight"><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre><p>新建完成后，指定文件夹目录下有：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558456bc458853aef6b3157.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558456bc458853aef6b3157.jpg"></p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的页面</p></li><li><p>scaffolds：md 模板</p></li><li><p>source：存放自己写的文档</p></li><li><p>themes：博客主题</p></li><li><p>_config.yml: 博客的配置文件</p></li></ul><p>生成相关文件并打开 hexo 服务：</p><pre class="highlight"><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre><p>在浏览器输入 localhost:4000 就可以看到生成的博客了（自己的操作没截图）</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://picx.zhimg.com/80/v2-d301dfbac9165b21ab1ee0a860f44de4_1440w.webp?source=2c26e567" class="lozad post-image"src="https://picx.zhimg.com/80/v2-d301dfbac9165b21ab1ee0a860f44de4_1440w.webp?source=2c26e567"></p><h2 id="4：创建-GitHub-个人仓库"><a href="#4：创建-GitHub-个人仓库" class="headerlink" title="4：创建 GitHub 个人仓库"></a><strong>4：创建 GitHub 个人仓库</strong></h2><p>新建仓库：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://picx.zhimg.com/80/v2-4387cb776ccc72189bc06fd511c1e19e_1440w.webp?source=2c26e567" class="lozad post-image"src="https://picx.zhimg.com/80/v2-4387cb776ccc72189bc06fd511c1e19e_1440w.webp?source=2c26e567"></p><p>创建一个和用户名相同的仓库，后面加.github.io，只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 <a href="http://xxxx.github.io,其中/">http://xxxx.github.io，其中</a> xxx 就是 GitHub 的用户名。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558857dc458853aef6715d9.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558857dc458853aef6715d9.jpg"></p><h2 id="5：生成添加到-GitHub"><a href="#5：生成添加到-GitHub" class="headerlink" title="5：生成添加到 GitHub"></a><strong>5：生成添加到 GitHub</strong></h2><p>首先将 git 的用户名和邮箱与 github 绑定：</p><pre class="highlight"><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre><p>yourname：GitHub 用户名，youremail：GitHub 绑定的邮箱。这样 Git 才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下有没有输对：</p><pre class="highlight"><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre><p>然后设置 token：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/6558874cc458853aef6d049a.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/6558874cc458853aef6d049a.jpg"></p><p>进入创建 Token 界面，下面的选项建议全部勾选：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65588876c458853aef712675.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65588876c458853aef712675.jpg"></p><p>关于 Token 的使用，最简单直接的方法就是当进行 git 操作时，直接将其做为密码进行使用。但需要注意：生成 token 后需要保存，因为之后 github 界面不会再显示已经 token。</p><h2 id="6：将-hexo-部署到-GitHub"><a href="#6：将-hexo-部署到-GitHub" class="headerlink" title="6：将 hexo 部署到 GitHub"></a><strong>6：将 hexo 部署到 GitHub</strong></h2><p>现在就可以将 hexo 和 GitHub 关联起来，也就是将 hexo 生成的文章部署到 GitHub page 上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为 YourgithubName 就是你的 GitHub 账户</p><pre class="highlight"><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/655889fbc458853aef760fcf.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/655889fbc458853aef760fcf.jpg"></p><p>这个时候需要先安装 deploy-git，也就是部署的命令，这样才能用命令将 hexo 部署到 GitHub。</p><pre class="highlight"><span class="line">npm install hexo-deployer-git --save</span><br></pre><p>然后：</p><pre class="highlight"><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre><p>其中 hexo clean 清除了你之前生成的东西，也可以不加。 <code>hexo generate</code>：生成静态文章，缩写为<code>hexo g</code>。<code>hexo deploy</code>：部署文章，缩写为<code>hexo d</code>。</p><p>注意 deploy 时可能要你输入 username 和 password，其中 password 输入前面生成的 token 就可以。</p><p>等一会就可以通过 <a href="http://yourname.github.io/">http://yourname.github.io</a> 访问 hexo 博客了。</p><h2 id="7：设置个人域名"><a href="#7：设置个人域名" class="headerlink" title="7：设置个人域名"></a><strong>7：设置个人域名</strong></h2><p>因为之前用过阿里云，所以在阿里云买了域名。购买后需要进行域名解析：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65588bb1c458853aef7b59f8.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65588bb1c458853aef7b59f8.jpg"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A_md_files/bcc8c810-85f9-11ee-a892-53a6ed2bbcfe.jpeg?v=1&type=image" class="lozad post-image"src="/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A_md_files/bcc8c810-85f9-11ee-a892-53a6ed2bbcfe.jpeg?v=1&type=image"></p><p>其中的 ip 地址是 github 服务器地址。</p><p>登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入购买的域名：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65588c78c458853aef7de517.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65588c78c458853aef7de517.jpg"></p><p>然后在存储博客 md 文件的 source 文件夹中创建一个名为 CNAME 文件，不要后缀，写上购买的域名：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65588d3fc458853aef809568.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65588d3fc458853aef809568.jpg"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic.imgdb.cn/item/65588d73c458853aef814ec7.jpg" class="lozad post-image"src="https://pic.imgdb.cn/item/65588d73c458853aef814ec7.jpg"></p><p>最后：</p><pre class="highlight"><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre><p>过不了多久，再打开浏览器，输入自己的域名，就可以看到搭建的网站啦！</p><p>接下来就可以正式开始写文章了。</p><pre class="highlight"><span class="line">hexo new newpapername</span><br></pre><p>然后在 source&#x2F;_post 中打开 markdown 文件，就可以开始编辑了。当写完的时候，再：</p><pre class="highlight"><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录搭建 hexo 博客的相关步骤，以备后续再次使用。文章参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20463581/answer/489125915&quot;&gt;https://www.zhihu.c</summary>
      
    
    
    
    <category term="搭建个人hexo博客" scheme="http://cstzzy.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="http://cstzzy.top/tags/hexo/"/>
    
  </entry>
  
</feed>
