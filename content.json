{"meta":{"title":"CSTZZY","subtitle":"个人主页","description":"个人主页","author":"ZZY","url":"http://cstzzy.top","root":"/"},"pages":[{"title":"about","text":"","path":"about/index.html","date":"11-17","excerpt":""}],"posts":[{"title":"在本地部署Overleaf","text":"一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。 安装Docker Desktop Docker官网 安装教程 使用Docker安装Overleaf 打开命令行cmd， 拉取 Overleaf 官方开源镜像，Overleaf版本参考地址： docker pull sharelatex/sharelatex:4.1.6 由于国内下载比较慢，需要等待挺长时间，可以参照 https://www.cnblogs.com/Flat-White/p/17107494.html 设置国内的Docker源。 前往 https://github.com/overleaf/overleaf/blob/main/docker-compose.yml 下载 docker-compose.yml 文件到本地； 对下载下来的docker-compose.yml 进行如下修改：(1): 将image: sharelatex&#x2F;sharelatex的版本修改为： image: sharelatex/sharelatex:4.1.6 (2): 将mongo部分的配置修改成如下所示： mongo: restart: always image: mongo:4.4 container_name: mongo command: &quot;--replSet overleaf&quot; expose: - 27017 volumes: - &quot;./mongo_data:/data/db&quot; healthcheck: test: echo &#x27;db.stats().ok&#x27; | mongo localhost:27017/test --quiet interval: 10s timeout: 10s retries: 5 mongoinit: image: mongo:4.4 # this container will exit after executing the command restart: &quot;no&quot; depends_on: mongo: condition: service_healthy entrypoint: [ &quot;mongo&quot;, &quot;--host&quot;, &quot;mongo:27017&quot;, &quot;--eval&quot;, &#x27;rs.initiate(&#123; _id: &quot;overleaf&quot;, members: [ &#123; _id: 0, host: &quot;mongo:27017&quot; &#125; ] &#125;)&#x27;, ] 命令行进入docker-compose.yml 文件所在目录下，然后执行： docker-compose up 通过访问http://127.0.0.1/launchpad 可以配置管理员账号。","path":"2023/12/01/13：在本地部署Overleaf/","date":"12-01","excerpt":"","tags":[{"name":"Overleaf","slug":"Overleaf","permalink":"http://cstzzy.top/tags/Overleaf/"}]},{"title":"Git版本回退","text":"Git版本回退git log命令显示从最近到最远的提交日志 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 回退到上一个版本：git reset --hard HEAD^ 如果我想恢复到回退前的版本呢？也可以的！只要有回退前版本的commit id就好了：git reset --hard &lt;commit id&gt; Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本的时候，Git仅需要改变HEAD的指向，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。Git提供了一个命令git reflog用来记录你的每一次命令： 8ddffe0 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to 8ddffe0c550c21810 HEAD@&#123;1&#125;: reset: moving to 0c218101c40f97b HEAD@&#123;2&#125;: reset: moving to HEAD^0c21810 HEAD@&#123;3&#125;: reset: moving to HEAD^8ddffe0 (HEAD -&gt; main) HEAD@&#123;4&#125;: commit: append GPL0c21810 HEAD@&#123;5&#125;: commit: add dsc40f97b HEAD@&#123;6&#125;: commit: add distributed3c16155 HEAD@&#123;7&#125;: commit (initial): wrote a readme file 从上述输出可以知道“append GPL”的commit id为8ddffe0，因此使用git reset --hard 8ddffe0即可。 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。","path":"2023/11/27/12：git-版本回退/","date":"11-27","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://cstzzy.top/tags/git/"}]},{"title":"LeetCode热题2","text":"字母异位词分组前言两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。 遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。 以下的两种方法分别使用排序和计数作为哈希表的键。 方法一：排序思路及算法： 由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。 class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string,vector&lt;string&gt;&gt; mp; for(string&amp; str:strs)&#123; string key=str; sort(key.begin(),key.end()); mp[key].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; res; for(auto it=mp.begin();it!=mp.end();it++)&#123; res.push_back(it-&gt;second); &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：$O(nk\\log⁡k)$，其中 n 是 strs 中的字符串的数量，k是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 $O(k \\log k)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nk \\log k)$。 空间复杂度：$O(nk)$，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。 注意：向vector添加元素有两种方法：push_back()和emplace_back()，要了解它们的区别。 方法二：计数没有第一种方法好，因此不详述，想了解可以去查看官方题解。","path":"2023/11/26/11：LeetCode热题2/","date":"11-26","excerpt":"","tags":[{"name":"c++","slug":"c","permalink":"http://cstzzy.top/tags/c/"},{"name":"LeetCode热题100","slug":"LeetCode热题100","permalink":"http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"}]},{"title":"LeetCode热题1","text":"两数之和方法一：暴力枚举思路及算法： 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。 当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。 class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i=0;i&lt;nums.size()-1;i++) &#123; for(int j=i+1;j&lt;nums.size();j++) &#123; if((nums[i]+nums[j])==target) return &#123;i,j&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 复杂度分析 时间复杂度：$O(N^2)$，其中N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。 空间复杂度：$O(1)$。 方法二：哈希表思路及算法： 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; hashtable; for(int i=0;i&lt;nums.size();i++)&#123; auto it=hashtable.find(target-nums[i]); if(it!=hashtable.end())&#123; return &#123;it-&gt;second,i&#125;; &#125; hashtable[nums[i]]=i; &#125; return &#123;&#125;; &#125;&#125;; 注意：这里用到了C++中的容器：unordered_map。","path":"2023/11/26/10：LeetCode热题1/","date":"11-26","excerpt":"","tags":[{"name":"c++","slug":"c","permalink":"http://cstzzy.top/tags/c/"},{"name":"LeetCode热题100","slug":"LeetCode热题100","permalink":"http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"}]},{"title":"Git查看修改内容与仓库状态","text":"Git查看修改内容与仓库状态我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件（在第一行插入单词”distributed”），改成如下内容： Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果： $ git statusOn branch mainChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .DS_Store git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： diff --git a/readme.txt b/readme.txtindex d8036c1..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software.\\ No newline at end of file git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 因为之前没有了解过Unix的diff命令的输出格式，因此去查了一下，记录如下： 上面展示的git diff的输出结果是合并格式的diff，除此之外还有其它两种格式（参考：Unix系统的diff工具程序）。 diff --git a/readme.txt b/readme.txt 表示进行比较的是，a版本的readme.txt（即变动前）和b版本的readme.txt（即变动后）。 index d8036c1..013b5bc 100644 第二行表示两个版本的git哈希值（index区域的d8036c1对象，与工作目录区域的013b5bc对象进行比较），100644是对象的模式（普通文件，644权限）。 --- a/readme.txt+++ b/readme.txt 表示文件的基本信息，“—”表示变动前的文件,”+++”表示变动后的文件。 @@ -1,2 +1,2 @@ 变动的位置用两个@作为起首和结束。 -1,2分成三个部分：减号表示变动前的文件，”1”表示第1行，“2”表示连续2行。合在一起，就表示下面是变动前的文件从第1行开始的连续2行。同样的，”+1,2”表示变动后的文件从第1行开始的连续2行。 最后除了有变动的那些行以外，还将两个文件的上下文合并显示在一起，所以叫做”合并格式”。每一行最前面的标志位，空表示无变动，减号表示变动前的文件删除的行，加号表示变动后的文件新增的行。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： git statusOn branch mainChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： git commit -m &quot;add distributed&quot; 提交后，我们再用git status命令看看仓库的当前状态： git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 上述例子仅展示了使用git add跟踪一个文件，还可以继续使用git add命令添加要跟踪的文件，之后如果修改了多个跟踪文件，则使用git diff时会分别显示各个文件的diff。","path":"2023/11/23/9：git-查看修改内容与仓库状态/","date":"11-23","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://cstzzy.top/tags/git/"}]},{"title":"Git创建版本库","text":"Git创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngitcd learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库： git init 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 编写一个readme.txt文件，内容如下： Git is a version control system.Git is free software. 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： git add readme.txt 使用git add .可以一次性添加所有修改。 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： git commit -m &quot;wrote a readme file&quot; 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件（到暂存区），比如： git add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot; 小结初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件；使用命令git commit -m ，完成。","path":"2023/11/23/8：git-创建版本库/","date":"11-23","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://cstzzy.top/tags/git/"}]},{"title":"Git简介","text":"Git简介CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。 集中式版本控制系统：版本库集中存放在中央服务器，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个完整的版本库，因此分布式比集中式安全：某台电脑坏了仅需要从其它电脑复制一份版本库即可，而中央服务器坏了就无法找回版本库了。利用分布式版本控制系统工作时就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 Git的优点：无需联网、分布式、强大的分制管理。其它免费版本控制系统： CVS：最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。 SVN：修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 了解完Git后下一步应该开始安装Git，但是MacBook已经安装了git，因此pass。","path":"2023/11/23/7：git-简介/","date":"11-23","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"http://cstzzy.top/tags/git/"}]},{"title":"","text":"{\"created_time\":\"2023-11-23T11:55:09Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"2\",\"modified_time\":\"2023-11-23T12:01:59Z\",\"name\":\"1：hexo初级搭建、github page部署及个人域名绑定.md\",\"signature\":\"784285914990853533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"3\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"2：hexo的基本配置、更换主题.md\",\"signature\":\"5546498803292388765\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"4\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"3：给个人博客添加RSS.md\",\"signature\":\"8223662518592028061\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"5\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"4：给个人博客添加评论系统.md\",\"signature\":\"8927815552003423645\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"6\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"5：c++中的int*, int *&.md\",\"signature\":\"1749579338025483677\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"7\",\"modified_time\":\"2023-11-26T10:37:43Z\",\"name\":\"6：排序算法总结.md\",\"signature\":\"4749813615771467165\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"12\",\"modified_time\":\"2023-11-23T12:56:14Z\",\"name\":\"7：git-简介.md\",\"signature\":\"207324067087533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"11\",\"modified_time\":\"2023-11-28T13:45:39Z\",\"name\":\"8：git-创建版本库.md\",\"signature\":\"8223662518592031744\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"14\",\"modified_time\":\"2023-11-23T14:20:53Z\",\"name\":\"9：git-查看修改内容与仓库状态.md\",\"signature\":\"8927815552003429748\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"17\",\"modified_time\":\"2023-11-27T05:12:58Z\",\"name\":\"10：LeetCode热题1.md\",\"signature\":\"207324067343228\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"19\",\"modified_time\":\"2023-11-26T12:38:00Z\",\"name\":\"11：LeetCode热题2.md\",\"signature\":\"784285914991114496\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"21\",\"modified_time\":\"2023-12-01T12:15:29Z\",\"name\":\"12：git-版本回退.md\",\"signature\":\"207324067418869\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"24\",\"modified_time\":\"2023-12-02T03:15:41Z\",\"name\":\"13：在本地部署Overleaf.md\",\"signature\":\"207324067778492\",\"tags\":[]}],\"folders\":[],\"id\":\"1\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"signature\":\"207324067085725\",\"version\":3}","path":"2023/11/23/vx/","date":"11-23","excerpt":"","tags":[]},{"title":"","text":"{\"attachment_folder\":\"vx_attachments\",\"config_mgr\":\"vx.vnotex\",\"created_time\":\"2023-11-23T11:55:09Z\",\"description\":\"myblog\",\"extra_configs\":{},\"history\":[],\"image_folder\":\"vx_images\",\"name\":\"_posts\",\"tag_graph\":\"\",\"version\":3,\"version_controller\":\"dummy.vnotex\"}","path":"2023/11/23/vx_notebook/vx_notebook/","date":"11-23","excerpt":"","tags":[]},{"title":"排序算法总结","text":"对常见的排序算法进行总结 名称 时间复杂度 算法核心思想 优点 缺点 桶排序（啊哈简化版） $O(m+n)$ 其中，m为桶的个数，n为待排序数的个数 比如有范围为 0-10 的数需要排序，则需要 11 个桶，每个桶 i 保存数字 i 出现的次数，然后遍历桶，按照桶 i 中存放的 i 出现的次数 k 输出 k 次 i。 1. 时间复杂度较小。 1. 比如需要对（姓名，得分）进行排序，使用桶排序无法知道各个分数对应的姓名； 冒泡排序 $O(n^2)$ 其中n为待排序数的个数 每次比较相邻的两个元素，如果顺序错误则交换这两个元素的顺序，且每一趟仅将一个元素归位，因此如果有 n 个数进行排序，则需要进行 n-1 趟操作。 - 1. 时间复杂度高。 快速排序 最大时间复杂度：$O(N^2)$ 平均时间复杂度：$O(NlogN)$ 其中n为待排序数的个数 每次以最左边的数为基准点，然后设置左右两个指针(i, j)分别指向待排序片段的最左侧和最右侧，然后先将右指针向左移动直到找到小于基准点的数或者与i相遇，再将左指针向右移动直到找到大于基准点的数或者与j相遇，然后交换i和j指向的数，重复上述过程直到i和j相遇，此时交换i指向的数与基准点，然后再对基准点左右两侧的数组片段重复上述过程，直到最终的片段只剩余一个数。 1. 平均时间复杂度较小； 2. 空间复杂度较小，仅需要使用一个额外存储空间以进行数组元素交换。 -","path":"2023/11/21/6：排序算法总结/","date":"11-21","excerpt":"","tags":[{"name":"c++","slug":"c","permalink":"http://cstzzy.top/tags/c/"},{"name":"排序算法总结","slug":"排序算法总结","permalink":"http://cstzzy.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"}]},{"title":"c++中的int*, int *&","text":"突然想起来之前本科学 C++的时候老师讲过int* 和int *&amp; 的区别，但是已经很多年没接触过了，现在回忆一下。 示例代码： #include&lt;iostream&gt;using namespace std;int main()&#123; int a=10; int &amp;b=a; cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;&amp;a=&quot;&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;&quot;&amp;b=&quot;&lt;&lt;&amp;b&lt;&lt;endl; int *p=&amp;a; int *&amp;pt=p; cout&lt;&lt;&quot;p=&quot;&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl; cout&lt;&lt;&quot;&amp;p=&quot;&lt;&lt;&amp;p&lt;&lt;endl; cout&lt;&lt;&quot;*&amp;p=&quot;&lt;&lt;*&amp;p&lt;&lt;endl; cout&lt;&lt;&quot;pt=&quot;&lt;&lt;pt&lt;&lt;endl; cout&lt;&lt;&quot;&amp;pt=&quot;&lt;&lt;&amp;pt&lt;&lt;endl; cout&lt;&lt;&quot;*&amp;pt=&quot;&lt;&lt;*&amp;pt&lt;&lt;endl; cout&lt;&lt;&quot;*&amp;a=&quot;&lt;&lt;*&amp;a&lt;&lt;endl;&#125; int &amp;b=a; 表示 b 是 a 的引用，简单来说，b 是 a 的别名，b 和 a 是同一个人，改变 b 也会改变 a，反之亦然， int *&amp;pt=p; 表示 pt 是指针 p 的引用，pt 和 p 是同一个人。 *&amp;p=p，*&amp;a=a 即：*&amp;XXX 相当于取 XXX 地址里存的东西，那自然是 XXX 本身了。 输出：","path":"2023/11/21/5：c++中的int*, int *&/","date":"11-21","excerpt":"","tags":[{"name":"c++","slug":"c","permalink":"http://cstzzy.top/tags/c/"},{"name":"指针","slug":"指针","permalink":"http://cstzzy.top/tags/%E6%8C%87%E9%92%88/"}]},{"title":"搭建个人 hexo 博客（4）","text":"参考链接：https://zhuanlan.zhihu.com/p/350704151这里使用 valine 实现评论，官方网 https://leancloud.cn/ 进入控制台后点击左下角创建应用 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用 Key，然后就能看到你的 APP ID 和 APP Key 了 开启评论功能 kaze/_config.yml comment: enable: true type: valine # valine | gitalk | livere | disqus | we recommend valine # gitalk config details can see in https://github.com/gitalk/gitalk/blob/master/readme-cn.md valine: appId: 你的appId appKey: 你的appKey","path":"2023/11/18/4：给个人博客添加评论系统/","date":"11-18","excerpt":"","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cstzzy.top/tags/hexo/"}]},{"title":"搭建个人hexo博客（3）","text":"1：什么是 RSS？RSS 也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。 2：为什么要用 RSS？就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过 RSS 订阅它们，然后在 RSS 阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过 RSS 订阅他。 在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么 RSS 订阅值得你的拥有。 3：添加 RSS 功能先安装 RSS 插件 npm i hexo-generator-feed 而后在你整个项目的_config.yml中找到 Extensions，添加： # Extensions## Plugins: https://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 这个时候你的 RSS 链接就是 域名/atom.xml了。 所以，在主题配置文件中的这个social links，开启 RSS 的页面功能，这样你网站上就有那个像 wifi 一样符号的 RSS logo 了，注意空格。 rss: /atom.xml 4：如何关注 RSS？首先，你需要一个 RSS 阅读器，在这里我推荐inoreader，宇宙第一 RSS 阅读器，而且中文支持的挺好。不过它没有 PC 端的程序，只有网页版，chrome 上有插件。在官网上用 google 账号或者自己注册账号登录，就可以开始你的关注之旅了。 每次需要关注某个博主时，就点开他的 RSS 链接，把链接复制到inoreader上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索阮一峰，应该就能出来了。 在安卓端，inoreader 也有下载，不过因为国内 google 是登录不了的，你需要在 inoreader 官网上把你的密码修改了，然后就可以用账户名和密码登录了。 在 IOS 端，没用过，好像是 reader 3 可以支持 inoreader 账户，还有个 readon 也不错，可以去试试。 ⚠️：按照上述步骤配置后网站打不开了，最后也没找到原因。","path":"2023/11/18/3：给个人博客添加RSS/","date":"11-18","excerpt":"","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cstzzy.top/tags/hexo/"}]},{"title":"搭建个人 hexo 博客（2）","text":"将 hexo 部署到 github 后就要进入下一步部分了：hexo 配置与主题个性化。 1：hexo 基本配置在文件根目录下的_config.yml，就是整个 hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数描述：title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址参数描：url网址root网站根目录permalink文章的 永久链接 格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫 temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。 参数结果：year/:month/:day/:title/2013&#x2F;07&#x2F;14&#x2F;hello-world:year-:month-:day-:title.html2013-07-14-hello-world.html:category/:titlefoo&#x2F;bar&#x2F;hello-world 再往下翻，中间这些都默认就好了。 theme: landscape​# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行 github page 部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是 md 文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数描述：layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 categories:- Diarytags:- PS3- Games layout（布局）当你每一次使用代码： hexo new paper 它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局路径postsource/_postspagesourcedraftsource/_drafts 而 new 这个命令其实是： hexo new [layout] &lt;title&gt; 只不过这个 layout 默认是 post 罢了。 page如果你想另起一页，那么可以使用 hexo new page board 系统会自动给你在 source 文件夹下创建一个 board 文件夹，以及 board 文件夹中的 index.md，这样你访问的 board 对应的链接就是http://xxx.xxx/board draftdraft 是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 hexo new draft newpage 这样会在 source&#x2F;_draft 中新建一个 newpage.md 文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到 post 中， hexo publish draft newpage 就会自动把 newpage.md 发送到 post 中。 2：更换主题官网的主题中，选择喜欢的主题进行修改，我选的是Kaze 。 去 github 上下载主题： 然后把下载的文件解压后放到： kaze 文件中也有一个_config.yml文件，这个文件用于配制主题，比如： menu（菜单栏） 其中，About 这个是找不到网页的，因为文章中没有 about 这个东西。如果想要的话，可以执行命令 hexo new page about 它就会在根目录下source文件夹中新建了一个about文件夹，以及 index.md，在 index.md 中写上想要写的东西，就可以在网站上展示出来了。 如果想要自己再自定义一个菜单栏的选项，那么就 hexo new page yourdiy 然后在主题配置文件的 menu 菜单栏添加一个 Yourdiy : /yourdiy，注意冒号后面要有空格，以及前面的空格要和 menu 中默认的保持整齐。然后在languages文件夹中，找到zh-CN.yml，在 index 中添加yourdiy: &#39;中文意思&#39;就可以显示中文了。","path":"2023/11/18/2：hexo的基本配置、更换主题/","date":"11-18","excerpt":"","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cstzzy.top/tags/hexo/"}]},{"title":"搭建个人hexo博客（1）","text":"记录搭建 hexo 博客的相关步骤，以备后续再次使用。文章参考链接： https://www.zhihu.com/question/20463581/answer/489125915 https://zhuanlan.zhihu.com/p/443038323 https://www.jianshu.com/p/87b70ec06c71 Hexo 搭建步骤 安装 Git（MacBook 自带 Git，因此跳过） 安装 Node.js（本科的时候做工程认证系统时安装过，因此跳过） 安装 Hexo GitHub 创建个人仓库 生成 SSH 添加到 GitHub（官方从 2021 年 8 月 13 日开始，在对 Git 操作进行身份验证时将不再接受帐户密码，并要求使用基于令牌的身份验证） 将 hexo 部署到 GitHub 设置个人域名（阿里云） 发布文章 1：安装 Git&#x20;MacBook 自带 Git，因此不需要安装。在这里记录一个学习 Git 的网站：https://www.liaoxuefeng.com/wiki/896043488029600。 2：安装 nodejs本科的时候做工程认证系统时安装过，因此跳过。 3：安装 hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，先创建一个文件夹 myblog，然后cd到这个文件夹下。&#x20; 输入命令： npm install -g hexo-cli 至此就全部安装完了。 接下来初始化 hexo： hexo init myblog 这个 myblog 可以自己取什么名字都行。 再安装相关依赖包： cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：md 模板 source：存放自己写的文档 themes：博客主题 _config.yml: 博客的配置文件 生成相关文件并打开 hexo 服务： hexo ghexo server 在浏览器输入 localhost:4000 就可以看到生成的博客了（自己的操作没截图） 4：创建 GitHub 个人仓库新建仓库： 创建一个和用户名相同的仓库，后面加.github.io，只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 http://xxxx.github.io，其中 xxx 就是 GitHub 的用户名。 5：生成添加到 GitHub首先将 git 的用户名和邮箱与 github 绑定： git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; yourname：GitHub 用户名，youremail：GitHub 绑定的邮箱。这样 Git 才能知道你是不是对应它的账户。 可以用以下两条，检查一下有没有输对： git config user.namegit config user.email 然后设置 token： 进入创建 Token 界面，下面的选项建议全部勾选： 关于 Token 的使用，最简单直接的方法就是当进行 git 操作时，直接将其做为密码进行使用。但需要注意：生成 token 后需要保存，因为之后 github 界面不会再显示已经 token。 6：将 hexo 部署到 GitHub现在就可以将 hexo 和 GitHub 关联起来，也就是将 hexo 生成的文章部署到 GitHub page 上，打开站点配置文件 _config.yml，翻到最后，修改为 YourgithubName 就是你的 GitHub 账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装 deploy-git，也就是部署的命令，这样才能用命令将 hexo 部署到 GitHub。 npm install hexo-deployer-git --save 然后： hexo cleanhexo generatehexo deploy 其中 hexo clean 清除了你之前生成的东西，也可以不加。 hexo generate：生成静态文章，缩写为hexo g。hexo deploy：部署文章，缩写为hexo d。 注意 deploy 时可能要你输入 username 和 password，其中 password 输入前面生成的 token 就可以。 等一会就可以通过 http://yourname.github.io 访问 hexo 博客了。 7：设置个人域名因为之前用过阿里云，所以在阿里云买了域名。购买后需要进行域名解析： 其中的 ip 地址是 github 服务器地址。 登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入购买的域名： 然后在存储博客 md 文件的 source 文件夹中创建一个名为 CNAME 文件，不要后缀，写上购买的域名： 最后： hexo cleanhexo ghexo d 过不了多久，再打开浏览器，输入自己的域名，就可以看到搭建的网站啦！ 接下来就可以正式开始写文章了。 hexo new newpapername 然后在 source&#x2F;_post 中打开 markdown 文件，就可以开始编辑了。当写完的时候，再： hexo cleanhexo ghexo d","path":"2023/11/18/1：hexo初级搭建、github page部署及个人域名绑定/","date":"11-18","excerpt":"","tags":[{"name":"hexo","slug":"hexo","permalink":"http://cstzzy.top/tags/hexo/"}]}],"categories":[],"tags":[{"name":"Overleaf","slug":"Overleaf","permalink":"http://cstzzy.top/tags/Overleaf/"},{"name":"git","slug":"git","permalink":"http://cstzzy.top/tags/git/"},{"name":"c++","slug":"c","permalink":"http://cstzzy.top/tags/c/"},{"name":"LeetCode热题100","slug":"LeetCode热题100","permalink":"http://cstzzy.top/tags/LeetCode%E7%83%AD%E9%A2%98100/"},{"name":"排序算法总结","slug":"排序算法总结","permalink":"http://cstzzy.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"指针","slug":"指针","permalink":"http://cstzzy.top/tags/%E6%8C%87%E9%92%88/"},{"name":"hexo","slug":"hexo","permalink":"http://cstzzy.top/tags/hexo/"}]}