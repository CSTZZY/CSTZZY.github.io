[{"title":"LeetCode热题1","url":"/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/","content":"两数之和方法一：暴力枚举思路及算法：\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        for(int i=0;i&lt;nums.size()-1;i++)        &#123;            for(int j=i+1;j&lt;nums.size();j++)            &#123;                if((nums[i]+nums[j])==target)                    return &#123;i,j&#125;;            &#125;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n复杂度分析\n时间复杂度：$O(N^2)$，其中N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n空间复杂度：$O(1)$。\n方法二：哈希表思路及算法：\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; hashtable;        for(int i=0;i&lt;nums.size();i++)&#123;            auto it=hashtable.find(target-nums[i]);            if(it!=hashtable.end())&#123;                return &#123;it-&gt;second,i&#125;;            &#125;            hashtable[nums[i]]=i;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n注意：这里用到了C++中的容器：unordered_map。\n","categories":["LeetCode热题100"],"tags":["c++","LeetCode热题100"]},{"title":"Git查看修改内容与仓库状态","url":"/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/","content":"Git查看修改内容与仓库状态我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件（在第一行插入单词”distributed”），改成如下内容：\nGit is a distributed version control system.Git is free software.\n\n现在，运行git status命令看看结果：\n$ git statusOn branch mainChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\t.DS_Store\n\ngit status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：\ndiff --git a/readme.txt b/readme.txtindex d8036c1..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software.\\ No newline at end of file\n\ngit diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。\n因为之前没有了解过Unix的diff命令的输出格式，因此去查了一下，记录如下：\n上面展示的git diff的输出结果是合并格式的diff，除此之外还有其它两种格式（参考：Unix系统的diff工具程序）。\ndiff --git a/readme.txt b/readme.txt\n表示进行比较的是，a版本的readme.txt（即变动前）和b版本的readme.txt（即变动后）。\nindex d8036c1..013b5bc 100644\n第二行表示两个版本的git哈希值（index区域的d8036c1对象，与工作目录区域的013b5bc对象进行比较），100644是对象的模式（普通文件，644权限）。\n--- a/readme.txt+++ b/readme.txt\n表示文件的基本信息，“—”表示变动前的文件,”+++”表示变动后的文件。\n@@ -1,2 +1,2 @@\n变动的位置用两个@作为起首和结束。\n-1,2分成三个部分：减号表示变动前的文件，”1”表示第1行，“2”表示连续2行。合在一起，就表示下面是变动前的文件从第1行开始的连续2行。同样的，”+1,2”表示变动后的文件从第1行开始的连续2行。\n最后除了有变动的那些行以外，还将两个文件的上下文合并显示在一起，所以叫做”合并格式”。每一行最前面的标志位，空表示无变动，减号表示变动前的文件删除的行，加号表示变动后的文件新增的行。\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\ngit add readme.txt\n同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：\ngit statusOn branch mainChanges to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)\tmodified:   readme.txt\n\ngit status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\ngit commit -m &quot;add distributed&quot;\n\n提交后，我们再用git status命令看看仓库的当前状态：\ngit statusOn branch masternothing to commit, working tree clean\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。\n小结\n要随时掌握工作区的状态，使用git status命令。\n如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n上述例子仅展示了使用git add跟踪一个文件，还可以继续使用git add命令添加要跟踪的文件，之后如果修改了多个跟踪文件，则使用git diff时会分别显示各个文件的diff。\n\n","categories":["git"],"tags":["git"]},{"title":"Git创建版本库","url":"/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","content":"Git创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\nmkdir learngitcd learngit\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\ngit init\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n编写一个readme.txt文件，内容如下：\nGit is a version control system.Git is free software.\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n第一步，用命令git add告诉Git，把文件添加到仓库：\ngit add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n第二步，用命令git commit告诉Git，把文件提交到仓库：\ngit commit -m &quot;wrote a readme file&quot;\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\ngit commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件（到暂存区），比如：\ngit add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot;\n\n小结初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n使用命令git add ，注意，可反复多次使用，添加多个文件；使用命令git commit -m ，完成。\n","categories":["git"],"tags":["git"]},{"title":"Git简介","url":"/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/","content":"Git简介CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。\n集中式版本控制系统：版本库集中存放在中央服务器，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个完整的版本库，因此分布式比集中式安全：某台电脑坏了仅需要从其它电脑复制一份版本库即可，而中央服务器坏了就无法找回版本库了。利用分布式版本控制系统工作时就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\nGit的优点：无需联网、分布式、强大的分制管理。其它免费版本控制系统：\n\nCVS：最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。\nSVN：修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n了解完Git后下一步应该开始安装Git，但是MacBook已经安装了git，因此pass。\n","categories":["git"],"tags":["git"]},{"title":"","url":"/2023/11/23/vx/","content":"{\"created_time\":\"2023-11-23T11:55:09Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"2\",\"modified_time\":\"2023-11-23T12:01:59Z\",\"name\":\"1：hexo初级搭建、github page部署及个人域名绑定.md\",\"signature\":\"784285914990853533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"3\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"2：hexo的基本配置、更换主题.md\",\"signature\":\"5546498803292388765\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"4\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"3：给个人博客添加RSS.md\",\"signature\":\"8223662518592028061\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"5\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"4：给个人博客添加评论系统.md\",\"signature\":\"8927815552003423645\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"6\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"5：c++中的int*, int *&.md\",\"signature\":\"1749579338025483677\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"7\",\"modified_time\":\"2023-11-26T10:37:43Z\",\"name\":\"6：排序算法总结.md\",\"signature\":\"4749813615771467165\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"12\",\"modified_time\":\"2023-11-23T12:56:14Z\",\"name\":\"7：git-简介.md\",\"signature\":\"207324067087533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"11\",\"modified_time\":\"2023-11-23T13:26:06Z\",\"name\":\"8：git-创建版本库.md\",\"signature\":\"8223662518592031744\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"14\",\"modified_time\":\"2023-11-23T14:20:53Z\",\"name\":\"9：git-查看修改内容与仓库状态.md\",\"signature\":\"8927815552003429748\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"17\",\"modified_time\":\"2023-11-26T11:59:24Z\",\"name\":\"10：LeetCode热题1.md\",\"signature\":\"207324067343228\",\"tags\":[]}],\"folders\":[],\"id\":\"1\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"signature\":\"207324067085725\",\"version\":3}","categories":[],"tags":[]},{"title":"","url":"/2023/11/23/vx_notebook/vx_notebook/","content":"{\"attachment_folder\":\"vx_attachments\",\"config_mgr\":\"vx.vnotex\",\"created_time\":\"2023-11-23T11:55:09Z\",\"description\":\"myblog\",\"extra_configs\":{},\"history\":[],\"image_folder\":\"vx_images\",\"name\":\"_posts\",\"tag_graph\":\"\",\"version\":3,\"version_controller\":\"dummy.vnotex\"}","categories":[],"tags":[]},{"title":"排序算法总结","url":"/2023/11/21/6%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"对常见的排序算法进行总结\n\n\n名称\n时间复杂度\n算法核心思想\n优点\n缺点\n\n\n\n桶排序（啊哈简化版）\n$O(m+n)$  其中，m为桶的个数，n为待排序数的个数\n比如有范围为 0-10 的数需要排序，则需要 11 个桶，每个桶 i 保存数字 i 出现的次数，然后遍历桶，按照桶 i 中存放的 i 出现的次数 k 输出 k 次 i。\n1. 时间复杂度较小。\n1. 比如需要对（姓名，得分）进行排序，使用桶排序无法知道各个分数对应的姓名；\n\n\n冒泡排序\n$O(n^2)$  其中n为待排序数的个数\n每次比较相邻的两个元素，如果顺序错误则交换这两个元素的顺序，且每一趟仅将一个元素归位，因此如果有 n 个数进行排序，则需要进行 n-1 趟操作。\n-\n1. 时间复杂度高。\n\n\n快速排序\n最大时间复杂度：$O(N^2)$  平均时间复杂度：$O(NlogN)$  其中n为待排序数的个数\n每次以最左边的数为基准点，然后设置左右两个指针(i, j)分别指向待排序片段的最左侧和最右侧，然后先将右指针向左移动直到找到小于基准点的数或者与i相遇，再将左指针向右移动直到找到大于基准点的数或者与j相遇，然后交换i和j指向的数，重复上述过程直到i和j相遇，此时交换i指向的数与基准点，然后再对基准点左右两侧的数组片段重复上述过程，直到最终的片段只剩余一个数。\n1. 平均时间复杂度较小；  2. 空间复杂度较小，仅需要使用一个额外存储空间以进行数组元素交换。\n-\n\n\n","categories":["ah算法"],"tags":["c++","排序算法总结"]},{"title":"c++中的int*, int *&","url":"/2023/11/21/5%EF%BC%9Ac++%E4%B8%AD%E7%9A%84int*,%20int%20*&/","content":"突然想起来之前本科学 C++的时候老师讲过int* 和int *&amp; 的区别，但是已经很多年没接触过了，现在回忆一下。\n示例代码：\n\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int a=10;    int &amp;b=a;    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;a=&quot;&lt;&lt;&amp;a&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;b=&quot;&lt;&lt;&amp;b&lt;&lt;endl;    int *p=&amp;a;    int *&amp;pt=p;    cout&lt;&lt;&quot;p=&quot;&lt;&lt;p&lt;&lt;endl;    cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;p=&quot;&lt;&lt;&amp;p&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;p=&quot;&lt;&lt;*&amp;p&lt;&lt;endl;    cout&lt;&lt;&quot;pt=&quot;&lt;&lt;pt&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;pt=&quot;&lt;&lt;&amp;pt&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;pt=&quot;&lt;&lt;*&amp;pt&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;a=&quot;&lt;&lt;*&amp;a&lt;&lt;endl;&#125;\n\n\nint &amp;b=a; 表示 b 是 a 的引用，简单来说，b 是 a 的别名，b 和 a 是同一个人，改变 b 也会改变 a，反之亦然，\n\nint *&amp;pt=p; 表示 pt 是指针 p 的引用，pt 和 p 是同一个人。\n\n*&amp;p=p，*&amp;a=a 即：*&amp;XXX 相当于取 XXX 地址里存的东西，那自然是 XXX 本身了。\n\n\n输出：\n\n","categories":["c++基础"],"tags":["c++","指针"]},{"title":"搭建个人 hexo 博客（4）","url":"/2023/11/18/4%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"参考链接：https://zhuanlan.zhihu.com/p/350704151这里使用 valine 实现评论，官方网  https://leancloud.cn/\n进入控制台后点击左下角创建应用\n\n应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用 Key，然后就能看到你的 APP ID 和 APP Key 了\n\n开启评论功能  kaze/_config.yml\ncomment:  enable: true  type: valine # valine | gitalk | livere | disqus | we recommend valine  # gitalk config details can see in https://github.com/gitalk/gitalk/blob/master/readme-cn.md  valine:    appId: 你的appId    appKey: 你的appKey\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人hexo博客（3）","url":"/2023/11/18/3%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/","content":"1：什么是 RSS？RSS 也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。\n2：为什么要用 RSS？就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过 RSS 订阅它们，然后在 RSS 阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过 RSS 订阅他。\n在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么 RSS 订阅值得你的拥有。\n3：添加 RSS 功能先安装 RSS 插件\nnpm i hexo-generator-feed\n\n而后在你整个项目的_config.yml中找到 Extensions，添加：\n# Extensions## Plugins: https://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20\n\n这个时候你的 RSS 链接就是 域名/atom.xml了。\n所以，在主题配置文件中的这个social links，开启 RSS 的页面功能，这样你网站上就有那个像 wifi 一样符号的 RSS logo 了，注意空格。\nrss: /atom.xml\n\n4：如何关注 RSS？首先，你需要一个 RSS 阅读器，在这里我推荐inoreader，宇宙第一 RSS 阅读器，而且中文支持的挺好。不过它没有 PC 端的程序，只有网页版，chrome 上有插件。在官网上用 google 账号或者自己注册账号登录，就可以开始你的关注之旅了。\n每次需要关注某个博主时，就点开他的 RSS 链接，把链接复制到inoreader上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索阮一峰，应该就能出来了。\n在安卓端，inoreader 也有下载，不过因为国内 google 是登录不了的，你需要在 inoreader 官网上把你的密码修改了，然后就可以用账户名和密码登录了。\n在 IOS 端，没用过，好像是 reader 3 可以支持 inoreader 账户，还有个 readon 也不错，可以去试试。\n⚠️：按照上述步骤配置后网站打不开了，最后也没找到原因。\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人 hexo 博客（2）","url":"/2023/11/18/2%EF%BC%9Ahexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E3%80%81%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","content":"将 hexo 部署到 github 后就要进入下一步部分了：hexo 配置与主题个性化。\n1：hexo 基本配置在文件根目录下的_config.yml，就是整个 hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。\n网站参数描述：title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。\n其中，description主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。\n\n网址参数描：url网址root网站根目录permalink文章的 永久链接 格式permalink_defaults永久链接中各部分的默认值\n在这里，你需要把url改成你的网站域名。\npermalink，也就是你生成某个文章时的那个链接格式。\n比如我新建一个文章叫 temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。\n以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。\n参数结果：year/:month/:day/:title/2013&#x2F;07&#x2F;14&#x2F;hello-world:year-:month-:day-:title.html2013-07-14-hello-world.html:category/:titlefoo&#x2F;bar&#x2F;hello-world\n\n再往下翻，中间这些都默认就好了。\ntheme: landscape​# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]\n\ntheme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。\n接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行 github page 部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。\n\nFront-matterFront-matter 是 md 文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n\n下是预先定义的参数，您可在模板中使用这些参数值并加以利用。\n参数描述：layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址\n其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。\ncategories:- Diarytags:- PS3- Games\n\nlayout（布局）当你每一次使用代码：\nhexo new paper\n\n它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。\nHexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。\n布局路径postsource/_postspagesourcedraftsource/_drafts\n而 new 这个命令其实是：\nhexo new [layout] &lt;title&gt;\n\n只不过这个 layout 默认是 post 罢了。\npage如果你想另起一页，那么可以使用\nhexo new page board\n\n系统会自动给你在 source 文件夹下创建一个 board 文件夹，以及 board 文件夹中的 index.md，这样你访问的 board 对应的链接就是http://xxx.xxx/board\ndraftdraft 是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以\nhexo new draft newpage\n\n这样会在 source&#x2F;_draft 中新建一个 newpage.md 文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用\nhexo server --draft\n\n在本地端口中开启服务预览。\n如果你的草稿文件写完了，想要发表到 post 中，\nhexo publish draft newpage\n\n就会自动把 newpage.md 发送到 post 中。\n2：更换主题官网的主题中，选择喜欢的主题进行修改，我选的是Kaze 。\n去 github 上下载主题：\n\n然后把下载的文件解压后放到：\n\nkaze 文件中也有一个_config.yml文件，这个文件用于配制主题，比如：\nmenu（菜单栏）\n其中，About 这个是找不到网页的，因为文章中没有 about 这个东西。如果想要的话，可以执行命令\nhexo new page about\n\n它就会在根目录下source文件夹中新建了一个about文件夹，以及 index.md，在 index.md 中写上想要写的东西，就可以在网站上展示出来了。\n\n如果想要自己再自定义一个菜单栏的选项，那么就\nhexo new page yourdiy\n\n然后在主题配置文件的 menu 菜单栏添加一个 Yourdiy : /yourdiy，注意冒号后面要有空格，以及前面的空格要和 menu 中默认的保持整齐。然后在languages文件夹中，找到zh-CN.yml，在 index 中添加yourdiy: &#39;中文意思&#39;就可以显示中文了。\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人hexo博客（1）","url":"/2023/11/18/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/","content":"记录搭建 hexo 博客的相关步骤，以备后续再次使用。文章参考链接：\n\nhttps://www.zhihu.com/question/20463581/answer/489125915\n\nhttps://zhuanlan.zhihu.com/p/443038323\n\nhttps://www.jianshu.com/p/87b70ec06c71\n\n\n\nHexo 搭建步骤\n安装 Git（MacBook 自带 Git，因此跳过）\n\n安装 Node.js（本科的时候做工程认证系统时安装过，因此跳过）\n\n安装 Hexo\n\nGitHub 创建个人仓库\n\n生成 SSH 添加到 GitHub（官方从 2021 年 8 月 13 日开始，在对 Git 操作进行身份验证时将不再接受帐户密码，并要求使用基于令牌的身份验证）\n\n将 hexo 部署到 GitHub\n\n设置个人域名（阿里云）\n\n发布文章\n\n\n1：安装 Git&#x20;MacBook 自带 Git，因此不需要安装。在这里记录一个学习 Git 的网站：https://www.liaoxuefeng.com/wiki/896043488029600。\n2：安装 nodejs本科的时候做工程认证系统时安装过，因此跳过。\n3：安装 hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，先创建一个文件夹 myblog，然后cd到这个文件夹下。&#x20;\n\n输入命令：\nnpm install -g hexo-cli\n\n至此就全部安装完了。\n接下来初始化 hexo：\nhexo init myblog\n\n这个 myblog 可以自己取什么名字都行。\n再安装相关依赖包：\ncd myblog //进入这个myblog文件夹npm install\n\n新建完成后，指定文件夹目录下有：\n\n\nnode_modules: 依赖包\n\npublic：存放生成的页面\n\nscaffolds：md 模板\n\nsource：存放自己写的文档\n\nthemes：博客主题\n\n_config.yml: 博客的配置文件\n\n\n生成相关文件并打开 hexo 服务：\nhexo ghexo server\n\n在浏览器输入 localhost:4000 就可以看到生成的博客了（自己的操作没截图）\n\n4：创建 GitHub 个人仓库新建仓库：\n\n创建一个和用户名相同的仓库，后面加.github.io，只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 http://xxxx.github.io，其中 xxx 就是 GitHub 的用户名。\n\n5：生成添加到 GitHub首先将 git 的用户名和邮箱与 github 绑定：\ngit config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;\n\nyourname：GitHub 用户名，youremail：GitHub 绑定的邮箱。这样 Git 才能知道你是不是对应它的账户。\n可以用以下两条，检查一下有没有输对：\ngit config user.namegit config user.email\n\n然后设置 token：\n\n进入创建 Token 界面，下面的选项建议全部勾选：\n\n关于 Token 的使用，最简单直接的方法就是当进行 git 操作时，直接将其做为密码进行使用。但需要注意：生成 token 后需要保存，因为之后 github 界面不会再显示已经 token。\n6：将 hexo 部署到 GitHub现在就可以将 hexo 和 GitHub 关联起来，也就是将 hexo 生成的文章部署到 GitHub page 上，打开站点配置文件 _config.yml，翻到最后，修改为 YourgithubName 就是你的 GitHub 账户\ndeploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master\n\n\n这个时候需要先安装 deploy-git，也就是部署的命令，这样才能用命令将 hexo 部署到 GitHub。\nnpm install hexo-deployer-git --save\n\n然后：\nhexo cleanhexo generatehexo deploy\n\n其中 hexo clean 清除了你之前生成的东西，也可以不加。 hexo generate：生成静态文章，缩写为hexo g。hexo deploy：部署文章，缩写为hexo d。\n注意 deploy 时可能要你输入 username 和 password，其中 password 输入前面生成的 token 就可以。\n等一会就可以通过 http://yourname.github.io 访问 hexo 博客了。\n7：设置个人域名因为之前用过阿里云，所以在阿里云买了域名。购买后需要进行域名解析：\n\n\n其中的 ip 地址是 github 服务器地址。\n登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入购买的域名：\n\n然后在存储博客 md 文件的 source 文件夹中创建一个名为 CNAME 文件，不要后缀，写上购买的域名：\n\n\n最后：\nhexo cleanhexo ghexo d\n\n过不了多久，再打开浏览器，输入自己的域名，就可以看到搭建的网站啦！\n接下来就可以正式开始写文章了。\nhexo new newpapername\n\n然后在 source&#x2F;_post 中打开 markdown 文件，就可以开始编辑了。当写完的时候，再：\nhexo cleanhexo ghexo d\n","categories":["搭建个人hexo博客"],"tags":["hexo"]}]