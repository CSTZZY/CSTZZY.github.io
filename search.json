[{"title":"LeetCode热题4","url":"/2023/12/10/24%EF%BC%9ALeetCode%E7%83%AD%E9%A2%984/","content":"接雨水方法一：动态规划思路及算法：\n对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。\n如果针对每一个元素都分别向左&#x2F;右扫描数组寻找左侧和右侧的最大值，则时间复杂度为$O(N^2)$。在已获得各个元素左右两侧最大高度的前提下，计算接雨水的总量的时间复杂度将变为$O(N)$，而使用动态规划的方法可以在时间复杂度为$O(N)$的前提下找到各个元素左右两侧的最大值，思路如下：\n\n创建两个长度为n的数组：leftmax和rightmax用来存储各个元素左右两侧的最大值；\nleftMax[0]&#x3D;height[0]，对于剩余的元素leftMax[i]&#x3D;max(leftMax[i−1],height[i])；\nrightMax[n−1]&#x3D;height[n−1]，对于剩余的元素rightMax[i]&#x3D;max(rightMax[i+1],height[i])；\n在得到leftmax和rightmax后，下标i所对应的接雨水量&#x3D;min(leftMax[i],rightMax[i])−height[i]。\n\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n=height.size();        vector&lt;int&gt; leftmax(n);        leftmax[0]=height[0];        for(int i=1;i&lt;n;i++)&#123;            leftmax[i]=max(height[i],leftmax[i-1]);        &#125;                vector&lt;int&gt; rightmax(n);        rightmax[n-1]=height[n-1];        for(int i=n-2;i&gt;=0;i--)&#123;            rightmax[i]=max(height[i],rightmax[i+1]);        &#125;                int res=0;        for(int i=0;i&lt;n;i++)&#123;            res=res+max(0,min(leftmax[i],rightmax[i])-height[i]);        &#125;        return res;    &#125;&#125;;\n其实上面的代码中的res&#x3D;res+max(0,min(leftmax[i],rightmax[i])-height[i]);没有必要写max(0,…)，因为min(leftmax[i],rightmax[i])的最小值为height[i]，即：min(leftmax[i],rightmax[i])-height[i]肯定为非负数。\n方法二：单调栈思路及算法：\n维护一个存储height数组下标的单调栈stack，其中从栈底到栈顶的下标对应的数组 height 中的元素递减。从头遍历height数组，若height[i]&lt;&#x3D;stack[stack.top()]或stack为空，则将i入栈；否则，int top&#x3D;stk.top(); stk.pop(); 若此时stack为空，则将i入栈，否则，此时得到一个可以接雨水的区域，left&#x3D;stk.top(); cur_width&#x3D;i-left-1; cur_height&#x3D;min(height[left],height[i])-height[top]; res+&#x3D;(cur_width*cur_height);重复上述过程，直到stack为空，或height[i]&lt;&#x3D;height[stk.top()]。\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int res=0;        stack&lt;int&gt; stk;        int n=height.size();        for(int i=0;i&lt;n;i++)&#123;            while(!stk.empty()&amp;&amp;height[i]&gt;height[stk.top()])&#123;                int top=stk.top();                stk.pop();                if(stk.empty())                    break;                int left=stk.top();                int cur_width=i-left-1;                int cur_height=min(height[left],height[i])-height[top];                res+=(cur_width*cur_height);            &#125;            stk.push(i);        &#125;        return res;    &#125;&#125;;\n\n方法三：双指针上述两种方法的空间复杂度都为$O(N)$，下面要介绍的双指针方法的空间复杂度为$O(1)$。\n下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。\nclass Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n=height.size();        int l=0;        int r=n-1;        int lmax=height[0];        int rmax=height[n-1];        int res=0;        while(l!=r)&#123;            if(height[l]&gt;=lmax)&#123;                lmax=height[l];            &#125;            if(height[r]&gt;=rmax)&#123;                rmax=height[r];            &#125;            if(height[l]&lt;height[r])&#123;                res+=(lmax-height[l++]);            &#125;            else&#123;                res+=(rmax-height[r--]);            &#125;        &#125;        return res;    &#125;&#125;;\n","categories":["LeetCode热题100"],"tags":["c++","LeetCode热题100"]},{"title":"Git使用SourceTree","url":"/2023/12/08/23%EF%BC%9Agit-%E4%BD%BF%E7%94%A8SourceTree/","content":"Git使用SourceTree使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。\nSourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。\n","categories":["git"],"tags":["git"]},{"title":"Git自定义git","url":"/2023/12/08/22%EF%BC%9Agit-%E8%87%AA%E5%AE%9A%E4%B9%89git/","content":"Git自定义git忽略特殊文件更详细的说明\n忽略某些文件时，需要编写.gitignore；\n.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！\n有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：如果你确实想添加该文件，可以用-f强制添加到Git：\ngit add -f App.class\n或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：\ngit check-ignore -v App.class\n\n# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class# 不排除.gitignore和App.class:!.gitignore!App.class\n\n配置别名搭建Git服务器暂时没有必要搭建一个单独的git服务器，因此只是简单了解了其搭建过程。\n","categories":["git"],"tags":["git"]},{"title":"GitGitub和Gitee的使用","url":"/2023/12/08/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"GitGithub和Gitee的使用的使用廖老师的教程中关于github的使用的介绍比较少，可以参考此链接中更详细的教程。\nGitee的使用与Github的使用基本相同。\n","categories":["git"],"tags":["git"]},{"title":"GitGitub和Gitee的使用","url":"/2023/12/08/vx_recycle_bin/20231208/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1.md/21%EF%BC%9Agit-github%E5%92%8CGitee%E7%9A%84%E4%BD%BF%E7%94%A8_1/","content":"GitGithub和Gitee的使用的使用廖老师的教程中关于github的使用的介绍比较少，可以参考此链接中更详细的教程。\nGitee的使用与Github的使用基本相同。\n","categories":["git"],"tags":["git"]},{"title":"Git标签管理","url":"/2023/12/08/20%EF%BC%9Agit-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/","content":"Git标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\nGit有commit，为什么还要引入tag？\n“请把上周一的那个版本打包发布，commit号是6a5819e…”\n“一串乱七八糟的数字不好找！”\n如果换一个办法：\n“请把上周一的那个版本打包发布，版本号是v1.2”\n“好的，按照tag v1.2查找commit就行！”\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\ngit branch\n然后，敲命令git tag &lt;tagname&gt;就可以打一个新标签。可以用命令git tag查看所有标签，用命令git show &lt;tagname&gt;查看标签信息。\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了：git tag &lt;tagname&gt; &lt;commit id&gt;\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\ngit tag -a &lt;tagname&gt; -m &quot;XXXXXX&quot; &lt;commit id&gt;\n\n如果标签打错了，也可以删除：\ngit tag -d &lt;tagname&gt;\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;，或者，一次性推送全部尚未推送到远程的本地标签git push origin --tags。\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\ngit tag -d &lt;tagname&gt;\n然后，从远程删除。删除命令也是push，但是格式如下：\ngit push origin :refs/tags/&lt;tagname&gt;\n","categories":["git"],"tags":["git"]},{"title":"Git分支管理","url":"/2023/12/06/19%EF%BC%9Agit-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","content":"Git分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n创建与合并分支的示意图见：创建与合并分支\nGit鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch \n切换分支：git checkout 或者git switch \n创建+切换分支：git checkout -b 或者git switch -c \n合并某分支到当前分支：git merge \n删除分支：git branch -d \n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n用git log –graph命令可以看到分支合并图。\nGit分支十分强大，在团队开发中应该充分应用。\n合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\nBug分支\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\nFeature分支\n开发一个新feature，最好新建一个分支；\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。\n多人协作\n多人协作的工作模式通常是这样：\n首先，可以试图用git push origin 推送自己的修改；\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n如果合并有冲突，则解决冲突，并在本地提交；\n没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to  origin&#x2F;。\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n总结查看远程库信息，使用git remote -v；\n本地新建的分支如果不推送到远程，对其他人就是不可见的；\n从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；\n建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；\n从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n注意：\n\n在进行git pull时可能会出现error: insufficient permission for adding an object to repository database .git&#x2F;objects，可参考此链接解决。\n\n进行git pull时会输出以下提示：\nhint: You have divergent branches and need to specify how to reconcile them.hint: You can do so by running one of the following commands sometime beforehint: your next pull:hint: hint:   git config pull.rebase false  # mergehint:   git config pull.rebase true   # rebasehint:   git config pull.ff only       # fast-forward onlyhint: hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a defaulthint: preference for all repositories. You can also pass --rebase, --no-rebase,hint: or --ff-only on the command line to override the configured default perhint: invocation.\n改为使用git config pull.rebase false，再git pull即可。\n\n在进行git checkout -b branch-name origin&#x2F;branch-name时可能会报错：fatal: ‘origin&#x2F;dev’ is not a commit and a branch ‘dev’ cannot be created from it，可参考此链接解决。\n\n\nRebase没太看懂举的例子，但是知道rebase操作的作用。\n\nrebase操作可以把本地未push的分叉提交历史整理成直线；\n\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n\n","categories":["git"],"tags":["git"]},{"title":"Git远程仓库","url":"/2023/12/06/18%EF%BC%9Agit-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","content":"Git远程仓库为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n\n在GitHub中创建一个名为learngit的仓库；\n在本地的learngit仓库下运行命令： $ git remote add origin https://github.com/CSTZZY/learngit.git\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n把本地库的所有内容推送到远程库上：git push -u origin main\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n从现在起，只要本地作了提交，就可以通过命令：git push -u origin main\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n如果你想删除远程库，可以先使用：git remote -v查看远程库的信息，然后根据远程库的名称使用git remote rm origin删除远程库。\n注意：此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n以上内容为先有本地库，后有远程库时，怎么关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills，并勾选Initialize this repository with a README。\n下一步是用命令git clone克隆一个本地库：\ngit clone git@github.com:CSTZZY/gitskills.git或者git clone https://github.com/CSTZZY/gitskills.git\n\nGitHub给出的地址不止一个。实际上，Git支持多种协议，&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;:CSTZZY&#x2F;gitskills.git使用ssh，但也可以使用https（如：https://github.com/CSTZZY/gitskills.git）等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\nGit支持多种协议，包括https，但ssh协议速度最快。\n这里对git push的讲解不是很全面，可以参考：https://blog.csdn.net/qq_37049311&#x2F;article&#x2F;details&#x2F;127932396。\n","categories":["git"],"tags":["git"]},{"title":"Git删除文件","url":"/2023/12/05/17%EF%BC%9Agit-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/","content":"Git删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：\n$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：\n$ rm test.txt\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：\n$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tdeleted:    test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：\n$ git rm test.txtrm &#x27;test.txt&#x27;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt\n\n现在，文件就从版本库中被删除了。\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n$ git checkout -- test.txt\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n 注意：从来没有被添加（git add）到版本库就被删除的文件，是无法恢复的！\n","categories":["git"],"tags":["git"]},{"title":"Git管理与撤销修改","url":"/2023/12/05/16%EF%BC%9Agit-%E7%AE%A1%E7%90%86%E4%B8%8E%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/","content":"Git管理与撤销修改管理修改为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n进行实验验证git管理的是修改：\n第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit\n按照上述过程操作，你会发现第二次的修改并没有被提交，这是因为Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：\n第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit\n撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时（没有进行git add 和 git commit），用命令git checkout – file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（仅使用了git add），想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时（已经使用了git add 和 git commit），想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\n注意：\n\n当使用git status查看git状态时，如果提示Changes not staged for commit，这表示没有使用git add，如果提示Changes to be committed，这表明已经使用git add将修改添加到了暂存取但没有使用git commit提交修改。\n先手动删除文件，然后使用git rm &lt;file&gt;和git add &lt;file&gt;效果是一样的。\n\n","categories":["git"],"tags":["git"]},{"title":"Git工作区和暂存区","url":"/2023/12/02/15%EF%BC%9Agit-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/","content":"Git工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。工作区（Working Directory）：就是你在电脑里能看到的目录。版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。下图可以形象的解释git add和git commit的作用：把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n","categories":["git"],"tags":["git"]},{"title":"LeetCode热题3","url":"/2023/12/02/14%EF%BC%9ALeetCode%E7%83%AD%E9%A2%983/","content":"最长连续序列首先介绍一开始我自己的想的方法，然后再介绍官方题解。\n方法一：我的方法思路及算法：\n首先对数组进行排序，并去重，然后从第一个元素向后匹配，注意：每个数仅遍历1次，下一次匹配的起点为当前匹配的终点的后一个元素。如果不算排序加去重的时间复杂度，那么这个方法的时间复杂度刚好为$O(N)$。\nclass Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()==0)            return 0;        sort(nums.begin(),nums.end());        unique(nums.begin(),nums.end());        int res=1;        int temp=1;        for(int i=0;i&lt;nums.size()-1;i++)&#123;            while(i&lt;(nums.size()-1)&amp;&amp;(nums[i+1]==(nums[i]+1)))&#123;                temp++;                i++;            &#125;            if(temp&gt;res)                res=temp;            temp=1;        &#125;        return res;    &#125;&#125;;\n\n方法二：哈希表由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。\nclass Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; num_set;        for(int num:nums)&#123;            num_set.insert(num);        &#125;        int res=0;        for(int num:num_set)&#123;            if(!num_set.count(num-1))&#123;                int cur_num=num;                int temp=1;                while(num_set.count(cur_num+1))&#123;                    cur_num++;                    temp++;                &#125;                if(temp&gt;res)                    res=temp;            &#125;        &#125;        return res;    &#125;&#125;;\n\n这个方法的运行时间为128ms，而我的方法运行时间只有80ms。\n注意：在leetcode中提交带有数组下标是否越界判断的语句时，如果先判断arr[i] &lt; arr[i+1]，再判断(i+1)&lt;&#x3D;len，这里i+1可能已经越界了，会导致此错误，需要改为先判断(i+1)&lt;&#x3D;len，再判断arr[i] &lt; arr[i+1]。参考链接： https://blog.csdn.net/adoge_/article/details/129072054\n","categories":["LeetCode热题100"],"tags":["c++","LeetCode热题100"]},{"title":"在本地部署Overleaf","url":"/2023/12/01/13%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Overleaf/","content":"一直在用在线的Overleaf，最近想要在本地部署一个Overleaf。\n\n安装Docker Desktop  Docker官网  安装教程\n使用Docker安装Overleaf\n\n\n打开命令行cmd， 拉取 Overleaf 官方开源镜像，Overleaf版本参考地址：\ndocker pull sharelatex/sharelatex:4.1.6\n由于国内下载比较慢，需要等待挺长时间，可以参照 https://www.cnblogs.com/Flat-White/p/17107494.html 设置国内的Docker源。\n\n前往 https://github.com/overleaf/overleaf/blob/main/docker-compose.yml 下载 docker-compose.yml 文件到本地；\n\n对下载下来的docker-compose.yml 进行如下修改：(1): 将image: sharelatex&#x2F;sharelatex的版本修改为：\nimage: sharelatex/sharelatex:4.1.6\n(2): 将mongo部分的配置修改成如下所示：\n mongo:     restart: always     image: mongo:4.4     container_name: mongo     command: &quot;--replSet overleaf&quot;     expose:       - 27017     volumes:       - &quot;./mongo_data:/data/db&quot;     healthcheck:       test: echo &#x27;db.stats().ok&#x27; | mongo localhost:27017/test --quiet       interval: 10s       timeout: 10s       retries: 5 mongoinit:     image: mongo:4.4     # this container will exit after executing the command     restart: &quot;no&quot;     depends_on:       mongo:         condition: service_healthy     entrypoint:       [         &quot;mongo&quot;,         &quot;--host&quot;,         &quot;mongo:27017&quot;,         &quot;--eval&quot;,         &#x27;rs.initiate(&#123; _id: &quot;overleaf&quot;, members: [ &#123; _id: 0, host: &quot;mongo:27017&quot; &#125; ] &#125;)&#x27;,       ]\n命令行进入docker-compose.yml 文件所在目录下，然后执行：\ndocker-compose up\n\n\n通过访问http://127.0.0.1/launchpad 可以配置管理员账号。\n\n","categories":["Overleaf"],"tags":["Overleaf"]},{"title":"Git版本回退","url":"/2023/11/27/12%EF%BC%9Agit-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","content":"Git版本回退git log命令显示从最近到最远的提交日志\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n回退到上一个版本：git reset --hard HEAD^\n如果我想恢复到回退前的版本呢？也可以的！只要有回退前版本的commit id就好了：git reset --hard &lt;commit id&gt;\n\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本的时候，Git仅需要改变HEAD的指向，然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。\n现在回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n在Git中，总是有后悔药可以吃的。Git提供了一个命令git reflog用来记录你的每一次命令：\n8ddffe0 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to 8ddffe0c550c21810 HEAD@&#123;1&#125;: reset: moving to 0c218101c40f97b HEAD@&#123;2&#125;: reset: moving to HEAD^0c21810 HEAD@&#123;3&#125;: reset: moving to HEAD^8ddffe0 (HEAD -&gt; main) HEAD@&#123;4&#125;: commit: append GPL0c21810 HEAD@&#123;5&#125;: commit: add dsc40f97b HEAD@&#123;6&#125;: commit: add distributed3c16155 HEAD@&#123;7&#125;: commit (initial): wrote a readme file\n从上述输出可以知道“append GPL”的commit id为8ddffe0，因此使用git reset --hard 8ddffe0即可。\n小结现在总结一下：\n\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n","categories":["git"],"tags":["git"]},{"title":"LeetCode热题2","url":"/2023/11/26/11%EF%BC%9ALeetCode%E7%83%AD%E9%A2%982/","content":"字母异位词分组前言两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。\n遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n以下的两种方法分别使用排序和计数作为哈希表的键。\n方法一：排序思路及算法：\n由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;        unordered_map&lt;string,vector&lt;string&gt;&gt; mp;        for(string&amp; str:strs)&#123;            string key=str;            sort(key.begin(),key.end());            mp[key].push_back(str);        &#125;        vector&lt;vector&lt;string&gt;&gt; res;        for(auto it=mp.begin();it!=mp.end();it++)&#123;            res.push_back(it-&gt;second);        &#125;        return res;    &#125;&#125;;\n\n复杂度分析\n时间复杂度：$O(nk\\log⁡k)$，其中 n 是 strs 中的字符串的数量，k是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 $O(k \\log k)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nk \\log k)$。\n空间复杂度：$O(nk)$，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。\n注意：向vector添加元素有两种方法：push_back()和emplace_back()，要了解它们的区别。\n方法二：计数没有第一种方法好，因此不详述，想了解可以去查看官方题解。\n","categories":["LeetCode热题100"],"tags":["c++","LeetCode热题100"]},{"title":"LeetCode热题1","url":"/2023/11/26/10%EF%BC%9ALeetCode%E7%83%AD%E9%A2%981/","content":"两数之和方法一：暴力枚举思路及算法：\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        for(int i=0;i&lt;nums.size()-1;i++)        &#123;            for(int j=i+1;j&lt;nums.size();j++)            &#123;                if((nums[i]+nums[j])==target)                    return &#123;i,j&#125;;            &#125;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n复杂度分析\n时间复杂度：$O(N^2)$，其中N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n空间复杂度：$O(1)$。\n方法二：哈希表思路及算法：\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从$O(N)$降低到$O(1)$。\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\nclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; hashtable;        for(int i=0;i&lt;nums.size();i++)&#123;            auto it=hashtable.find(target-nums[i]);            if(it!=hashtable.end())&#123;                return &#123;it-&gt;second,i&#125;;            &#125;            hashtable[nums[i]]=i;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n注意：这里用到了C++中的容器：unordered_map。\n","categories":["LeetCode热题100"],"tags":["c++","LeetCode热题100"]},{"title":"Git查看修改内容与仓库状态","url":"/2023/11/23/9%EF%BC%9Agit-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81/","content":"Git查看修改内容与仓库状态我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件（在第一行插入单词”distributed”），改成如下内容：\nGit is a distributed version control system.Git is free software.\n\n现在，运行git status命令看看结果：\n$ git statusOn branch mainChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\t.DS_Store\n\ngit status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：\ndiff --git a/readme.txt b/readme.txtindex d8036c1..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software.\\ No newline at end of file\n\ngit diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。\n因为之前没有了解过Unix的diff命令的输出格式，因此去查了一下，记录如下：\n上面展示的git diff的输出结果是合并格式的diff，除此之外还有其它两种格式（参考：Unix系统的diff工具程序）。\ndiff --git a/readme.txt b/readme.txt\n表示进行比较的是，a版本的readme.txt（即变动前）和b版本的readme.txt（即变动后）。\nindex d8036c1..013b5bc 100644\n第二行表示两个版本的git哈希值（index区域的d8036c1对象，与工作目录区域的013b5bc对象进行比较），100644是对象的模式（普通文件，644权限）。\n--- a/readme.txt+++ b/readme.txt\n表示文件的基本信息，“—”表示变动前的文件,”+++”表示变动后的文件。\n@@ -1,2 +1,2 @@\n变动的位置用两个@作为起首和结束。\n-1,2分成三个部分：减号表示变动前的文件，”1”表示第1行，“2”表示连续2行。合在一起，就表示下面是变动前的文件从第1行开始的连续2行。同样的，”+1,2”表示变动后的文件从第1行开始的连续2行。\n最后除了有变动的那些行以外，还将两个文件的上下文合并显示在一起，所以叫做”合并格式”。每一行最前面的标志位，空表示无变动，减号表示变动前的文件删除的行，加号表示变动后的文件新增的行。\n知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：\ngit add readme.txt\n同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：\ngit statusOn branch mainChanges to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)\tmodified:   readme.txt\n\ngit status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：\ngit commit -m &quot;add distributed&quot;\n\n提交后，我们再用git status命令看看仓库的当前状态：\ngit statusOn branch masternothing to commit, working tree clean\n\nGit告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。\n小结\n要随时掌握工作区的状态，使用git status命令。\n如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n上述例子仅展示了使用git add跟踪一个文件，还可以继续使用git add命令添加要跟踪的文件，之后如果修改了多个跟踪文件，则使用git diff时会分别显示各个文件的diff。\n\n","categories":["git"],"tags":["git"]},{"title":"Git创建版本库","url":"/2023/11/23/8%EF%BC%9Agit-%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","content":"Git创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\nmkdir learngitcd learngit\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：\ngit init\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n编写一个readme.txt文件，内容如下：\nGit is a version control system.Git is free software.\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n第一步，用命令git add告诉Git，把文件添加到仓库：\ngit add readme.txt\n\n使用git add .可以一次性添加所有修改。\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n第二步，用命令git commit告诉Git，把文件提交到仓库：\ngit commit -m &quot;wrote a readme file&quot;\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\ngit commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件（到暂存区），比如：\ngit add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot;\n\n小结初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n使用命令git add ，注意，可反复多次使用，添加多个文件；使用命令git commit -m ，完成。\n","categories":["git"],"tags":["git"]},{"title":"Git简介","url":"/2023/11/23/7%EF%BC%9Agit-%E7%AE%80%E4%BB%8B/","content":"Git简介CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统。\n集中式版本控制系统：版本库集中存放在中央服务器，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个完整的版本库，因此分布式比集中式安全：某台电脑坏了仅需要从其它电脑复制一份版本库即可，而中央服务器坏了就无法找回版本库了。利用分布式版本控制系统工作时就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\nGit的优点：无需联网、分布式、强大的分制管理。其它免费版本控制系统：\n\nCVS：最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。\nSVN：修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。\n\n除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。\n微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。\n分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！\n了解完Git后下一步应该开始安装Git，但是MacBook已经安装了git，因此pass。\n","categories":["git"],"tags":["git"]},{"title":"","url":"/2023/11/23/vx/","content":"{\"created_time\":\"2023-11-23T11:55:09Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"2\",\"modified_time\":\"2023-11-23T12:01:59Z\",\"name\":\"1：hexo初级搭建、github page部署及个人域名绑定.md\",\"signature\":\"784285914990853533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"3\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"2：hexo的基本配置、更换主题.md\",\"signature\":\"5546498803292388765\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"4\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"3：给个人博客添加RSS.md\",\"signature\":\"8223662518592028061\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"5\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"4：给个人博客添加评论系统.md\",\"signature\":\"8927815552003423645\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"6\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"name\":\"5：c++中的int*, int *&.md\",\"signature\":\"1749579338025483677\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"7\",\"modified_time\":\"2023-11-26T10:37:43Z\",\"name\":\"6：排序算法总结.md\",\"signature\":\"4749813615771467165\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"12\",\"modified_time\":\"2023-11-23T12:56:14Z\",\"name\":\"7：git-简介.md\",\"signature\":\"207324067087533\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"11\",\"modified_time\":\"2023-11-28T13:45:39Z\",\"name\":\"8：git-创建版本库.md\",\"signature\":\"8223662518592031744\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"14\",\"modified_time\":\"2023-11-23T14:20:53Z\",\"name\":\"9：git-查看修改内容与仓库状态.md\",\"signature\":\"8927815552003429748\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"17\",\"modified_time\":\"2023-11-27T05:12:58Z\",\"name\":\"10：LeetCode热题1.md\",\"signature\":\"207324067343228\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"19\",\"modified_time\":\"2023-11-26T12:38:00Z\",\"name\":\"11：LeetCode热题2.md\",\"signature\":\"784285914991114496\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"21\",\"modified_time\":\"2023-12-01T12:15:29Z\",\"name\":\"12：git-版本回退.md\",\"signature\":\"207324067418869\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"24\",\"modified_time\":\"2023-12-02T03:15:41Z\",\"name\":\"13：在本地部署Overleaf.md\",\"signature\":\"207324067778492\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"26\",\"modified_time\":\"2024-01-03T11:19:37Z\",\"name\":\"14：LeetCode热题3.md\",\"signature\":\"207324067854486\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"28\",\"modified_time\":\"2023-12-02T12:30:16Z\",\"name\":\"15：git-工作区和暂存区.md\",\"signature\":\"784285914991630751\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"30\",\"modified_time\":\"2023-12-06T01:03:27Z\",\"name\":\"16：git-管理与撤销修改.md\",\"signature\":\"207324068127003\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"32\",\"modified_time\":\"2023-12-05T13:43:31Z\",\"name\":\"17：git-删除文件.md\",\"signature\":\"784285914991896562\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"34\",\"modified_time\":\"2023-12-06T11:50:59Z\",\"name\":\"18：git-远程仓库.md\",\"signature\":\"207324068199273\",\"tags\":[]},{\"attachment_folder\":\"238732412626092\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"36\",\"modified_time\":\"2023-12-09T03:43:56Z\",\"name\":\"19：git-分支管理.md\",\"signature\":\"784285914991976579\",\"tags\":[]},{\"attachment_folder\":\"238732412626092_1\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"38\",\"modified_time\":\"2023-12-08T08:45:45Z\",\"name\":\"20：git-标签管理.md\",\"signature\":\"207324068369132\",\"tags\":[]},{\"attachment_folder\":\"238732412626092_1_1\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"41\",\"modified_time\":\"2023-12-08T09:35:44Z\",\"name\":\"21：git-github和Gitee的使用.md\",\"signature\":\"784285914992138967\",\"tags\":[]},{\"attachment_folder\":\"238732412626092_1_2\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"43\",\"modified_time\":\"2023-12-08T11:20:59Z\",\"name\":\"22：git-自定义git.md\",\"signature\":\"784285914992145164\",\"tags\":[]},{\"attachment_folder\":\"238732412626092_1_2_1\",\"created_time\":\"2023-11-23T12:25:17Z\",\"id\":\"45\",\"modified_time\":\"2023-12-08T11:25:05Z\",\"name\":\"23：git-使用SourceTree.md\",\"signature\":\"5546498803293682881\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2023-11-23T11:55:09Z\",\"id\":\"47\",\"modified_time\":\"2023-12-10T09:28:45Z\",\"name\":\"24：LeetCode热题4.md\",\"signature\":\"207324068521812\",\"tags\":[]}],\"folders\":[],\"id\":\"1\",\"modified_time\":\"2023-11-23T11:55:09Z\",\"signature\":\"207324067085725\",\"version\":3}","categories":[],"tags":[]},{"title":"","url":"/2023/11/23/vx_notebook/vx_notebook/","content":"{\"attachment_folder\":\"vx_attachments\",\"config_mgr\":\"vx.vnotex\",\"created_time\":\"2023-11-23T11:55:09Z\",\"description\":\"myblog\",\"extra_configs\":{},\"history\":[],\"image_folder\":\"vx_images\",\"name\":\"_posts\",\"tag_graph\":\"\",\"version\":3,\"version_controller\":\"dummy.vnotex\"}","categories":[],"tags":[]},{"title":"排序算法总结","url":"/2023/11/21/6%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"对常见的排序算法进行总结\n\n\n名称\n时间复杂度\n算法核心思想\n优点\n缺点\n\n\n\n桶排序（啊哈简化版）\n$O(m+n)$  其中，m为桶的个数，n为待排序数的个数\n比如有范围为 0-10 的数需要排序，则需要 11 个桶，每个桶 i 保存数字 i 出现的次数，然后遍历桶，按照桶 i 中存放的 i 出现的次数 k 输出 k 次 i。\n1. 时间复杂度较小。\n1. 比如需要对（姓名，得分）进行排序，使用桶排序无法知道各个分数对应的姓名；\n\n\n冒泡排序\n$O(n^2)$  其中n为待排序数的个数\n每次比较相邻的两个元素，如果顺序错误则交换这两个元素的顺序，且每一趟仅将一个元素归位，因此如果有 n 个数进行排序，则需要进行 n-1 趟操作。\n-\n1. 时间复杂度高。\n\n\n快速排序\n最大时间复杂度：$O(N^2)$  平均时间复杂度：$O(NlogN)$  其中n为待排序数的个数\n每次以最左边的数为基准点，然后设置左右两个指针(i, j)分别指向待排序片段的最左侧和最右侧，然后先将右指针向左移动直到找到小于基准点的数或者与i相遇，再将左指针向右移动直到找到大于基准点的数或者与j相遇，然后交换i和j指向的数，重复上述过程直到i和j相遇，此时交换i指向的数与基准点，然后再对基准点左右两侧的数组片段重复上述过程，直到最终的片段只剩余一个数。\n1. 平均时间复杂度较小；  2. 空间复杂度较小，仅需要使用一个额外存储空间以进行数组元素交换。\n-\n\n\n","categories":["ah算法"],"tags":["c++","排序算法总结"]},{"title":"c++中的int*, int *&","url":"/2023/11/21/5%EF%BC%9Ac++%E4%B8%AD%E7%9A%84int*,%20int%20*&/","content":"突然想起来之前本科学 C++的时候老师讲过int* 和int *&amp; 的区别，但是已经很多年没接触过了，现在回忆一下。\n示例代码：\n\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int a=10;    int &amp;b=a;    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;a=&quot;&lt;&lt;&amp;a&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;b=&quot;&lt;&lt;&amp;b&lt;&lt;endl;    int *p=&amp;a;    int *&amp;pt=p;    cout&lt;&lt;&quot;p=&quot;&lt;&lt;p&lt;&lt;endl;    cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;p=&quot;&lt;&lt;&amp;p&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;p=&quot;&lt;&lt;*&amp;p&lt;&lt;endl;    cout&lt;&lt;&quot;pt=&quot;&lt;&lt;pt&lt;&lt;endl;    cout&lt;&lt;&quot;&amp;pt=&quot;&lt;&lt;&amp;pt&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;pt=&quot;&lt;&lt;*&amp;pt&lt;&lt;endl;    cout&lt;&lt;&quot;*&amp;a=&quot;&lt;&lt;*&amp;a&lt;&lt;endl;&#125;\n\n\nint &amp;b=a; 表示 b 是 a 的引用，简单来说，b 是 a 的别名，b 和 a 是同一个人，改变 b 也会改变 a，反之亦然，\n\nint *&amp;pt=p; 表示 pt 是指针 p 的引用，pt 和 p 是同一个人。\n\n*&amp;p=p，*&amp;a=a 即：*&amp;XXX 相当于取 XXX 地址里存的东西，那自然是 XXX 本身了。\n\n\n输出：\n\n","categories":["c++基础"],"tags":["c++","指针"]},{"title":"搭建个人 hexo 博客（4）","url":"/2023/11/18/4%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"参考链接：https://zhuanlan.zhihu.com/p/350704151这里使用 valine 实现评论，官方网  https://leancloud.cn/\n进入控制台后点击左下角创建应用\n\n应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用 Key，然后就能看到你的 APP ID 和 APP Key 了\n\n开启评论功能  kaze/_config.yml\ncomment:  enable: true  type: valine # valine | gitalk | livere | disqus | we recommend valine  # gitalk config details can see in https://github.com/gitalk/gitalk/blob/master/readme-cn.md  valine:    appId: 你的appId    appKey: 你的appKey\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人hexo博客（3）","url":"/2023/11/18/3%EF%BC%9A%E7%BB%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/","content":"1：什么是 RSS？RSS 也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。\n2：为什么要用 RSS？就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过 RSS 订阅它们，然后在 RSS 阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过 RSS 订阅他。\n在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么 RSS 订阅值得你的拥有。\n3：添加 RSS 功能先安装 RSS 插件\nnpm i hexo-generator-feed\n\n而后在你整个项目的_config.yml中找到 Extensions，添加：\n# Extensions## Plugins: https://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20\n\n这个时候你的 RSS 链接就是 域名/atom.xml了。\n所以，在主题配置文件中的这个social links，开启 RSS 的页面功能，这样你网站上就有那个像 wifi 一样符号的 RSS logo 了，注意空格。\nrss: /atom.xml\n\n4：如何关注 RSS？首先，你需要一个 RSS 阅读器，在这里我推荐inoreader，宇宙第一 RSS 阅读器，而且中文支持的挺好。不过它没有 PC 端的程序，只有网页版，chrome 上有插件。在官网上用 google 账号或者自己注册账号登录，就可以开始你的关注之旅了。\n每次需要关注某个博主时，就点开他的 RSS 链接，把链接复制到inoreader上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索阮一峰，应该就能出来了。\n在安卓端，inoreader 也有下载，不过因为国内 google 是登录不了的，你需要在 inoreader 官网上把你的密码修改了，然后就可以用账户名和密码登录了。\n在 IOS 端，没用过，好像是 reader 3 可以支持 inoreader 账户，还有个 readon 也不错，可以去试试。\n⚠️：按照上述步骤配置后网站打不开了，最后也没找到原因。\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人 hexo 博客（2）","url":"/2023/11/18/2%EF%BC%9Ahexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E3%80%81%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","content":"将 hexo 部署到 github 后就要进入下一步部分了：hexo 配置与主题个性化。\n1：hexo 基本配置在文件根目录下的_config.yml，就是整个 hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。\n网站参数描述：title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。\n其中，description主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。\n\n网址参数描：url网址root网站根目录permalink文章的 永久链接 格式permalink_defaults永久链接中各部分的默认值\n在这里，你需要把url改成你的网站域名。\npermalink，也就是你生成某个文章时的那个链接格式。\n比如我新建一个文章叫 temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。\n以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。\n参数结果：year/:month/:day/:title/2013&#x2F;07&#x2F;14&#x2F;hello-world:year-:month-:day-:title.html2013-07-14-hello-world.html:category/:titlefoo&#x2F;bar&#x2F;hello-world\n\n再往下翻，中间这些都默认就好了。\ntheme: landscape​# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]\n\ntheme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。\n接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行 github page 部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。\n\nFront-matterFront-matter 是 md 文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n\n下是预先定义的参数，您可在模板中使用这些参数值并加以利用。\n参数描述：layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址\n其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。\ncategories:- Diarytags:- PS3- Games\n\nlayout（布局）当你每一次使用代码：\nhexo new paper\n\n它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。\nHexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。\n布局路径postsource/_postspagesourcedraftsource/_drafts\n而 new 这个命令其实是：\nhexo new [layout] &lt;title&gt;\n\n只不过这个 layout 默认是 post 罢了。\npage如果你想另起一页，那么可以使用\nhexo new page board\n\n系统会自动给你在 source 文件夹下创建一个 board 文件夹，以及 board 文件夹中的 index.md，这样你访问的 board 对应的链接就是http://xxx.xxx/board\ndraftdraft 是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以\nhexo new draft newpage\n\n这样会在 source&#x2F;_draft 中新建一个 newpage.md 文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用\nhexo server --draft\n\n在本地端口中开启服务预览。\n如果你的草稿文件写完了，想要发表到 post 中，\nhexo publish draft newpage\n\n就会自动把 newpage.md 发送到 post 中。\n2：更换主题官网的主题中，选择喜欢的主题进行修改，我选的是Kaze 。\n去 github 上下载主题：\n\n然后把下载的文件解压后放到：\n\nkaze 文件中也有一个_config.yml文件，这个文件用于配制主题，比如：\nmenu（菜单栏）\n其中，About 这个是找不到网页的，因为文章中没有 about 这个东西。如果想要的话，可以执行命令\nhexo new page about\n\n它就会在根目录下source文件夹中新建了一个about文件夹，以及 index.md，在 index.md 中写上想要写的东西，就可以在网站上展示出来了。\n\n如果想要自己再自定义一个菜单栏的选项，那么就\nhexo new page yourdiy\n\n然后在主题配置文件的 menu 菜单栏添加一个 Yourdiy : /yourdiy，注意冒号后面要有空格，以及前面的空格要和 menu 中默认的保持整齐。然后在languages文件夹中，找到zh-CN.yml，在 index 中添加yourdiy: &#39;中文意思&#39;就可以显示中文了。\n","categories":["搭建个人hexo博客"],"tags":["hexo"]},{"title":"搭建个人hexo博客（1）","url":"/2023/11/18/1%EF%BC%9Ahexo%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%E3%80%81github%20page%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/","content":"记录搭建 hexo 博客的相关步骤，以备后续再次使用。文章参考链接：\n\nhttps://www.zhihu.com/question/20463581/answer/489125915\n\nhttps://zhuanlan.zhihu.com/p/443038323\n\nhttps://www.jianshu.com/p/87b70ec06c71\n\n\n\nHexo 搭建步骤\n安装 Git（MacBook 自带 Git，因此跳过）\n\n安装 Node.js（本科的时候做工程认证系统时安装过，因此跳过）\n\n安装 Hexo\n\nGitHub 创建个人仓库\n\n生成 SSH 添加到 GitHub（官方从 2021 年 8 月 13 日开始，在对 Git 操作进行身份验证时将不再接受帐户密码，并要求使用基于令牌的身份验证）\n\n将 hexo 部署到 GitHub\n\n设置个人域名（阿里云）\n\n发布文章\n\n\n1：安装 Git&#x20;MacBook 自带 Git，因此不需要安装。在这里记录一个学习 Git 的网站：https://www.liaoxuefeng.com/wiki/896043488029600。\n2：安装 nodejs本科的时候做工程认证系统时安装过，因此跳过。\n3：安装 hexo前面 git 和 nodejs 安装好后，就可以安装 hexo 了，先创建一个文件夹 myblog，然后cd到这个文件夹下。&#x20;\n\n输入命令：\nnpm install -g hexo-cli\n\n至此就全部安装完了。\n接下来初始化 hexo：\nhexo init myblog\n\n这个 myblog 可以自己取什么名字都行。\n再安装相关依赖包：\ncd myblog //进入这个myblog文件夹npm install\n\n新建完成后，指定文件夹目录下有：\n\n\nnode_modules: 依赖包\n\npublic：存放生成的页面\n\nscaffolds：md 模板\n\nsource：存放自己写的文档\n\nthemes：博客主题\n\n_config.yml: 博客的配置文件\n\n\n生成相关文件并打开 hexo 服务：\nhexo ghexo server\n\n在浏览器输入 localhost:4000 就可以看到生成的博客了（自己的操作没截图）\n\n4：创建 GitHub 个人仓库新建仓库：\n\n创建一个和用户名相同的仓库，后面加.github.io，只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 http://xxxx.github.io，其中 xxx 就是 GitHub 的用户名。\n\n5：生成添加到 GitHub首先将 git 的用户名和邮箱与 github 绑定：\ngit config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;\n\nyourname：GitHub 用户名，youremail：GitHub 绑定的邮箱。这样 Git 才能知道你是不是对应它的账户。\n可以用以下两条，检查一下有没有输对：\ngit config user.namegit config user.email\n\n然后设置 token：\n\n进入创建 Token 界面，下面的选项建议全部勾选：\n\n关于 Token 的使用，最简单直接的方法就是当进行 git 操作时，直接将其做为密码进行使用。但需要注意：生成 token 后需要保存，因为之后 github 界面不会再显示已经 token。\n6：将 hexo 部署到 GitHub现在就可以将 hexo 和 GitHub 关联起来，也就是将 hexo 生成的文章部署到 GitHub page 上，打开站点配置文件 _config.yml，翻到最后，修改为 YourgithubName 就是你的 GitHub 账户\ndeploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master\n\n\n这个时候需要先安装 deploy-git，也就是部署的命令，这样才能用命令将 hexo 部署到 GitHub。\nnpm install hexo-deployer-git --save\n\n然后：\nhexo cleanhexo generatehexo deploy\n\n其中 hexo clean 清除了你之前生成的东西，也可以不加。 hexo generate：生成静态文章，缩写为hexo g。hexo deploy：部署文章，缩写为hexo d。\n注意 deploy 时可能要你输入 username 和 password，其中 password 输入前面生成的 token 就可以。\n等一会就可以通过 http://yourname.github.io 访问 hexo 博客了。\n7：设置个人域名因为之前用过阿里云，所以在阿里云买了域名。购买后需要进行域名解析：\n\n\n其中的 ip 地址是 github 服务器地址。\n登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入购买的域名：\n\n然后在存储博客 md 文件的 source 文件夹中创建一个名为 CNAME 文件，不要后缀，写上购买的域名：\n\n\n最后：\nhexo cleanhexo ghexo d\n\n过不了多久，再打开浏览器，输入自己的域名，就可以看到搭建的网站啦！\n接下来就可以正式开始写文章了。\nhexo new newpapername\n\n然后在 source&#x2F;_post 中打开 markdown 文件，就可以开始编辑了。当写完的时候，再：\nhexo cleanhexo ghexo d\n","categories":["搭建个人hexo博客"],"tags":["hexo"]}]